# [스프링 핵심 원리 - 고급편](../)

## 2. 예제 만들기

### 4. 프로젝트 생성

### 5. 예제 프로젝트 만들기 - V0

- 백엔드 기본 흐름 예제 구현

### 6. 로그 추적기 - 요구사항 분석

### 7. 로그 추적기 V1 - 프로토타입 개발

### 8. 로그 추적기 V1 - 적용

- trace.exception() 으로 예외까지 처리해야 하므로 지저분한 try , catch 코드가 추가된다.
- 예외를 꼭 다시 던져 흐름을 막지말자

- 아직 구현하지 못한 요구사항은 메서드 호출의 깊이를 표현하고, 같은 HTTP 요청이면 같은 트랜잭션 ID를 남기는 것 이다.
- 이 기능은 직전 로그의 깊이와 트랜잭션 ID가 무엇인지 알아야 할 수 있는 일이다.
- 결국 현재 로그의 상태 정보인 트랜잭션ID 와 level 이 다음으로 전달되어야 한다.
- **정리하면 로그에 대한 문맥( Context ) 정보가 필요하다.**

### 9. 로그 추적기 V2 - 파라미터로 동기화 개발

### 10. 로그 추적기 V2 - 적용

### 11. 정리

- 드디어 모든 요구사항을 만족했다.

- 하지만 남은 문제

  - HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 동기화가 필요하다.
  - **TraceId 의 동기화를 위해서 관련 메서드의 모든 파라미터를 수정해야 한다.**
  - 만약 인터페이스가 있다면 인터페이스까지 모두 고쳐야 하는 상황이다.
  - 로그를 처음 시작할 때는 begin() 을 호출하고, 처음이 아닐때는 beginSync() 를 호출해야 한다.
  - 만약에 컨트롤러를 통해서 서비스를 호출하는 것이 아니라, 다른 곳에서 서비스를 처음으로 호출하는 상황이라면 파리미터로 넘길 TraceId 가 없다.

- **HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 를 파라미터로 넘기는 것 말고 다른 대안은 없을까?**

- 이 예제를 작성하며 느낀건데, 트랜잭션 id를 분리한다는 개념이 클라이언트에서 없는 것 같다.

## 3. 쓰레드 로컬 - ThreadLocal

### 12. 필드 동기화 - 개발

### 13. 필드 동기화 - 적용

### 14. 필드 동기화 - 동시성 문제

### 15. 동시성 문제 - 예제 코드

### 16. ThreadLocal - 소개

### 17. ThreadLocal - 예제 코드

### 18. 쓰레드 로컬 동기화 - 개발

### 19. 쓰레드 로컬 동기화 - 적용

### 20. 쓰레드 로컬 - 주의사항

### 21. 정리

## 4. 템플릿 메서드 패턴과 콜백 패턴

### 22. 템플릿 메서드 패턴 - 시작

### 23. 템플릿 메서드 패턴 - 예제1

### 24. 템플릿 메서드 패턴 - 예제2

### 25. 템플릿 메서드 패턴 - 예제3

### 26. 템플릿 메서드 패턴 - 적용1

### 27. 템플릿 메서드 패턴 - 적용2

### 28. 템플릿 메서드 패턴 - 정의

### 29. 전략 패턴 - 시작

### 30. 전략 패턴 - 예제1

### 31. 전략 패턴 - 예제2

### 32. 전략 패턴 - 예제3

### 33. 템플릿 콜백 패턴 - 시작

### 34. 템플릿 콜백 패턴 - 예제

### 35. 템플릿 콜백 패턴 - 적용

### 36. 정리

## 5. 프록시 패턴과 데코레이터 패턴

### 37. 프로젝트 생성

### 38. 예제 프로젝트 만들기 v1

### 39. 예제 프로젝트 만들기 v2

### 40. 예제 프로젝트 만들기 v3

### 41. 요구사항 추가

### 42. 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

### 43. 프록시 패턴 - 예제 코드1

### 44. 프록시 패턴 - 예제 코드2

### 45. 데코레이터 패턴 - 예제 코드1

### 46. 데코레이터 패턴 - 예제 코드2

### 47. 데코레이터 패턴 - 예제 코드3

### 48. 프록시 패턴과 데코레이터 패턴 정리

### 49. 인터페이스 기반 프록시 - 적용

### 50. 구체 클래스 기반 프록시 - 예제1

### 51. 구체 클래스 기반 프록시 - 예제2

### 52. 구체 클래스 기반 프록시 - 적용

### 53. 인터페이스 기반 프록시와 클래스 기반 프록시

### 54. 정리

## 6. 동적 프록시 기술

### 55. 리플렉션

### 56. JDK 동적 프록시 - 소개

### 57. JDK 동적 프록시 - 예제 코드

### 58. JDK 동적 프록시 - 적용1

### 59. JDK 동적 프록시 - 적용2

### 60. CGLIB - 소개

### 61. CGLIB - 예제 코드

### 62. 정리

## 7. 스프링이 지원하는 프록시

### 63. 프록시 팩토리 - 소개

### 64. 프록시 팩토리 - 예제 코드1

### 65. 프록시 팩토리 - 예제 코드2

### 66. 포인트컷, 어드바이스, 어드바이저 - 소개

### 67. 예제 코드1 - 어드바이저

### 68. 예제 코드2 - 직접 만든 포인트컷

### 69. 예제 코드3 - 스프링이 제공하는 포인트컷

### 70. 예제 코드4 - 여러 어드바이저 함께 적용

### 71. 프록시 팩토리 - 적용1

### 72. 프록시 팩토리 - 적용2

### 73. 정리

## 8. 빈 후처리기

### 74. 빈 후처리기 - 소개

### 75. 빈 후처리기 - 예제 코드1

### 76. 빈 후처리기 - 예제 코드2

### 77. 빈 후처리기 - 적용

### 78. 빈 후처리기 - 정리

### 79. 스프링이 제공하는 빈 후처리기1

### 80. 스프링이 제공하는 빈 후처리기2

### 81. 하나의 프록시, 여러 Advisor 적용

### 82. 정리

## 9. @Aspect AOP

### 83. @Aspect 프록시 - 적용

### 84. @Aspect 프록시 - 설명

### 85. 정리

## 10. 스프링 AOP 개념

### 86. AOP 소개 - 핵심 기능과 부가 기능

### 87. AOP 소개 - 애스펙트

### 88. AOP 적용 방식

### 89. AOP 용어 정리

### 90. 정리

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

### 95. 스프링 AOP 구현3 - 어드바이스 추가

### 96. 스프링 AOP 구현4 - 포인트컷 참조

### 97. 스프링 AOP 구현5 - 어드바이스 순서

### 98. 스프링 AOP 구현6 - 어드바이스 종류

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리

## 15. 다음으로

### 125. 다음으로
