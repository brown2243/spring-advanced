# [스프링 핵심 원리 - 고급편](../)

## 5. 프록시 패턴과 데코레이터 패턴

### 37. 프로젝트 생성

### 38. 예제 프로젝트 만들기 v1

- v1 - 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- v2 - 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- v3 - 컴포넌트 스캔으로 스프링 빈 자동 등록

- @Import(AppV1Config.class) : 클래스를 스프링 빈으로 등록한다.
- @SpringBootApplication(scanBasePackages = "hello.proxy.app"): 컴포넌트 스캔을 시작할 위치를 지정한다. 해당 패키지와 그 하위 패키지를 컴포넌트 스캔한다.

### 39. 예제 프로젝트 만들기 v2

### 40. 예제 프로젝트 만들기 v3

- **개발할 때, V3가 일반적이다.**
- V1 방식을 사용해야 할 때
  - 구현체를 쉽게 갈아 끼워야 할 때 (DI의 핵심)
    - 인터페이스에만 의존하므로, 서비스 코드 수정 없이 설정 파일에서 @Bean으로 등록하는 구현체만 변경
  - Spring AOP의 프록시를 적용할 때
    - 스프링의 AOP는 기본적으로 프록시 기술을 사용합니다.
    - 인터페이스가 있으면 스프링은 JDK 동적 프록시를 사용하여 프록시를 더 쉽게 만들어냅니다.
- V2: 구체 클래스 수동 등록
  - 직접 수정할 수 없는 외부 라이브러리의 클래스를 빈으로 등록할 때 사용

### 41. 요구사항 추가

- 가장 어려운 문제는 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입하는 것이다. 이 문제를 해결하려면 프록시(Proxy)의 개념을 먼저 이해해야 한다.

### 42. 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

- 클라이언트와 서버의 기본 개념을 정의하면 클라이언트는 서버에 필요한 것을 요청하고, 서버는 클라이언트의 요청을 처리하는 것이다.

- 그런데 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할 수 있다.
- 예를 들어서 내가 직접 마트에서 장을 볼 수도 있지만, 누군가에게 대신 장을 봐달라고 부탁할 수도 있다.
- **여기서 대신 장을 보는 대리자를 영어로 프록시(Proxy)라 한다.**
- 재미있는 점은 직접 호출과 다르게 간접 호출을 하면 대리자가 중간에서 여러가지 일을 할 수 있다는 점이다.
- 엄마에게 라면을 사달라고 부탁 했는데, 엄마는 그 라면은 이미 집에 있다고 할 수도 있다. 그러면 기대한 것 보다 더 빨리 라면을 먹을 수 있다. (접근 제어, 캐싱)
- 아버지께 자동차 주유를 부탁했는데, 아버지가 주유 뿐만 아니라 세차까지 하고 왔다. 클라이언트가 기대한 것 외에 세차라는 부가 기능까지 얻게 되었다. (부가 기능 추가)
- 그리고 대리자가 또 다른 대리자를 부를 수도 있다. 예를 들어서 내가 동생에게 라면을 사달라고 했는데, 동생은 또 다른 누군가에게 라면을 사달라고 다시 요청할 수도 있다.
- 중요한 점은 클라이언트는 대리자를 통해서 요청했기 때문에 그 이후 과정은 모른다는 점이다. 동생을 통해서 라면이 나에게 도착하기만 하면 된다. (프록시 체인)

#### 대체 가능

- 객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.
- 그러므로 서버와 프록시는 같은 인터페이스를 사용해야 한다.
- 클라이언트 객체에 DI를 사용해서 Client -> Server 에서 Client -> Proxy 로 객체 의존관계를 변경해도 클라이언트 코드를 전혀 변경하지 않아도 된다. 클라이언트 입장에서는 변경 사실 조차 모른다.
- DI를 사용하면 클라이언트 코드의 변경 없이 유연하게 프록시를 주입할 수 있다.

#### 프록시의 주요 기능

- 프록시 객체가 중간에 있으면 크게 접근 제어와 부가 기능 추가를 수행할 수 있다.
- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
  - 예) 요청 값이나, 응답 값을 중간에 변형한다.
  - 예) 실행 시간을 측정해서 추가 로그를 남긴다.

#### GOF 디자인 패턴

- 둘다 프록시를 사용하는 방법이지만 GOF 디자인 패턴에서는 이 둘을 의도(intent)에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다.
- 프록시 패턴: 접근 제어가 목적
- 데코레이터 패턴: 새로운 기능 추가가 목적
- 둘다 프록시를 사용하지만, 의도가 다르다는 점이 핵심이다.

### 43. 프록시 패턴 - 예제 코드1

- 이 데이터가 한번 조회하면 변하지 않는 데이터라면 어딘가에 보관해두고 이미 조회한 데이터를 사용하는 것이 성능상 좋다.
- 이런 것을 캐시라고 한다.
- 프록시 패턴의 주요 기능은 접근 제어이다. 캐시도 접근 자체를 제어하는 기능 중 하나이다.

### 44. 프록시 패턴 - 예제 코드2

- client -> cacheProxy -> realSubject 런타임 객체 의존 관계가 완성된다.
- 프록시 패턴의 핵심은 RealSubject 코드와 클라이언트 코드를 전혀 변경하지 않고, 프록시를 도입해서 접근 제어를 했다는 점이다.

### 45. 데코레이터 패턴 - 예제 코드1

### 46. 데코레이터 패턴 - 예제 코드2

- 프록시로 부가 기능을 추가하는 것을 데코레이터 패턴이라 한다.

### 47. 데코레이터 패턴 - 예제 코드3

### 48. 프록시 패턴과 데코레이터 패턴 정리

- 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 의도에 따라 패턴을 구분한다.

- 프록시 패턴의 의도: 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- 데코레이터 패턴의 의도: 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공

- 프록시를 사용하고 해당 프록시가 접근 제어가 목적이라면 프록시 패턴이고, 새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이 된다.

### 49. 인터페이스 기반 프록시 - 적용

- 프록시를 사용하면 기존 코드를 전혀 수정하지 않고 로그 추적 기능을 도입할 수 있다.

1. Controller , Service , Repository 각각 인터페이스에 맞는 프록시 구현체를 추가한다.
2. 런타임에 프록시를 사용하도록 의존 관계 설정

### 50. 구체 클래스 기반 프록시 - 예제1

### 51. 구체 클래스 기반 프록시 - 예제2

- 지금까지 인터페이스를 기반으로 프록시를 도입했다.
- 그런데 자바의 다형성은 인터페이스를 구현하든, 아니면 클래스를 상속하든 상위 타입만 맞으면 다형성이 적용된다.
- 이번에는 인터페이스가 아니라 클래스를 기반으로 상속을 받아서 프록시를 만들어보겠다.

### 52. 구체 클래스 기반 프록시 - 적용

- 클래스 기반의 프록시는 구체 클래스를 상속받아 구현
- 프록시는 부모 객체의 기능을 사용하지 않기 때문에 super(null) 을 입력해도 된다.

### 53. 인터페이스 기반 프록시와 클래스 기반 프록시

- 인터페이스가 없어도 클래스 기반으로 프록시를 생성할 수 있다.
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다.
- 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다.
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.

  - 부모 클래스의 생성자를 호출해야 한다.(앞서 본 예제)
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다.
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

- 인터페이스 기반의 프록시는 상속이라는 제약에서 자유롭다.
- 프로그래밍 관점에서도 인터페이스를 사용하는 것이 역할과 구현을 명확하게 나누기 때문에 더 좋다.
- 인터페이스 기반 프록시의 단점은 인터페이스가 필요하다는 그 자체이다.
- 이론적으로는 모든 객체에 인터페이스를 도입해서 역할과 구현을 나누는 것이 좋다.
- 하지만 실제로는 구현을 거의 변경할 일이 없는 클래스도 많다.
- **인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적인데, 구현을 변경할 가능성이 거의 없는 코드에 무작정 인터페이스를 사용하는 것은 번거롭고 그렇게 실용적이지 않다.**
- 이런곳에는 실용적인 관점에서 인터페이스를 사용하지 않고 구체 클래스를 바로 사용하는 것이 좋다 생각한다.

#### 너무 많은 프록시 클래스

- 지금까지 프록시를 사용해서 기존 코드를 변경하지 않고, 로그 추적기라는 부가 기능을 적용할 수 있었다.
- 그런데 문제는 프록시 클래스를 너무 많이 만들어야 한다는 점이다.
  - 잘 보면 프록시 클래스가 하는 일은 LogTrace 를 사용하는 것인데, 그 로직이 모두 똑같다. 대상 클래스만 다를 뿐이다.
  - 만약 적용해야 하는 대상 클래스가 100개라면 프록시 클래스도 100개를 만들어야한다.
- 바로 다음에 설명할 동적 프록시 기술이 이 문제를 해결해준다.

### 54. 정리

## 6. 동적 프록시 기술

### 55. 리플렉션

- [JS에도 Reflect API가 있다](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Proxy-Reflect-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%B2%95).

- 자바가 기본으로 제공하는 JDK 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다.
- 프록시를 적용할 코드를 하나만 만들어두고 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.
- JDK 동적 프록시를 이해하기 위해서는 먼저 자바의 리플렉션 기술을 이해해야 한다.
- 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.

- 쉬워 보이지만 메서드로 뽑아서 공통화하는 것이 생각보다 어렵다. 왜냐하면 중간에 호출하는 메서드가 다르기 때문이다.

  - 이 부분은 사실 자바는 함수를 인자로 넘길 수 없어서 그렇다.
  - 8부터는 람다(Lambda) 덕분에 마치 함수를 직접 넘기는 것처럼 이 방식을 아주 간결하게 표현할 수 있다

- **리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.**
- **리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.**
- 따라서 리플렉션은 일반적으로 사용하면 안된다.
- 리플렉션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다.

### 56. JDK 동적 프록시 - 소개

- 동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다.
- **프록시 객체를 동적으로 런타임에 개발자 대신 만들어준다. 그리고 동적 프록시에 원하는 실행 로직을 지정할 수 있다.**
- JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. **따라서 인터페이스가 필수이다.**

### 57. JDK 동적 프록시 - 예제 코드

1. 클라이언트는 JDK 동적 프록시의 call() 을 실행한다.
2. JDK 동적 프록시는 InvocationHandler.invoke() 를 호출한다. TimeInvocationHandler 가 구현체로 있으로 TimeInvocationHandler.invoke() 가 호출된다.
3. TimeInvocationHandler 가 내부 로직을 수행하고, method.invoke(target, args) 를 호출해서 target 인 실제 객체( AImpl )를 호출한다.
4. AImpl 인스턴스의 call() 이 실행된다.
5. AImpl 인스턴스의 call() 의 실행이 끝나면 TimeInvocationHandler 로 응답이 돌아온다. 시간 로그를 출력하고 결과를 반환한다.

- JDK 동적 프록시 기술 덕분에 적용 대상 만큼 프록시 객체를 만들지 않아도 된다.
- 같은 부가 기능 로직을 한번만 개발해서 공통으로 적용할 수 있다.
- 적용 대상이 100개여도 동적 프록시를 통해서 생성하고, 각각 필요한 InvocationHandler 만 만들어서 넣어주면 된다.
- **결과적으로 프록시 클래스를 수 없이 만들어야 하는 문제도 해결하고, 부가 기능 로직도 하나의 클래스에 모아서 단일 책임 원칙(SRP)도 지킬 수 있게 되었다.**

### 58. JDK 동적 프록시 - 적용1

1. 클라이언트의 호출: 클라이언트가 proxy.call()처럼 프록시 객체의 메서드를 호출합니다.
2. JVM의 가로채기: JVM은 이 객체가 동적 프록시인 것을 인지하고, call() 메서드를 직접 실행하는 대신 이 프록시와 연결된 InvocationHandler(즉, LogTraceBasicHandler)를 찾아냅니다.
3. 핸들러에게 위임: JVM은 방금 호출된 call 메서드의 정보(Method 객체), 인자(args 배열) 등을 모두 담아서 LogTraceBasicHandler의 invoke 메서드를 실행시킵니다.
4. 핸들러 로직 실행: invoke 메서드 내부의 코드가 실행됩니다.
5. method.invoke(target, args): 리플렉션을 사용해 드디어 **원본 객체(target)**의 실제 메서드를 호출합니다. (핵심 기능 위임)
6. 결과 반환: invoke 메서드가 반환한 결과가 최종적으로 클라이언트에게 전달됩니다.

#### JS/TS Proxy 객체와의 비교

- 자바의 JDK 동적 프록시는 인터페이스를 기반으로 동작하기 때문에, 인터페이스에 정의된 메서드 호출만 가로챌 수 있습니다.
- 인터페이스에는 멤버 변수(프로퍼티/필드)를 정의할 수 없으므로, target 객체의 프로퍼티에 직접 접근하는 것을 중간에서 가로채는 개념 자체가 없습니다.
- JS/TS의 Proxy는 메서드 호출뿐만 아니라 프로퍼티(속성)에 대한 접근도 가로챌 수 있습니다. 이는 handler 객체에 정의하는 트랩(Trap) 덕분입니다.

- 결론적으로 자바의 프록시 기술(JDK 동적 프록시, CGLIB)은 근본적으로 메서드 호출을 가로채는 데에 초점이 맞춰져 있습니다.

### 59. JDK 동적 프록시 - 적용2

### 60. CGLIB - 소개

- CGLIB는 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.
- CGLIB를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
- CGLIB는 원래는 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함했다.
- 따라서 스프링을 사용한다면 별도의 외부 라이브러리를 추가하지 않아도 사용할 수 있다.

- 참고로 우리가 CGLIB를 직접 사용하는 경우는 거의 없다.
- 이후에 설명할 스프링의 ProxyFactory 라는 것이 이 기술을 편리하게 사용하게 도와주기 때문에, 너무 깊이있게 파기 보다는 CGLIB가 무엇인지 대략 개념만 잡으면 된다.

### 61. CGLIB - 예제 코드

- JDK 동적 프록시는 인터페이스를 구현(implement)해서 프록시를 만든다.
- CGLIB는 구체 클래스를 상속(extends)해서 프록시를 만든다.

#### CGLIB 제약

- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
- 부모 클래스의 생성자를 체크해야 한다. CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
- 클래스에 final 키워드가 붙으면 상속이 불가능하다. CGLIB에서는 예외가 발생한다.
- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.
- CGLIB에서는 프록시 로직이 동작하지 않는다.

### 62. 정리

- 남은 문제
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해서 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor 를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

## 7. 스프링이 지원하는 프록시

### 63. 프록시 팩토리 - 소개

- 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 스프링은 유사한 구체적인 기술들이 있을 때, 그것들을 통합해서 일관성 있게 접근할 수 있고, 더욱 편리하게 사용할 수 있는 추상화된 기술을 제공한다.
- **스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리( ProxyFactory )라는 기능을 제공한다.**
- 이 프록시 팩토리 하나로 편리하게 동적 프록시를 생성할 수 있다.
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 그리고 이 설정을 변경할 수도 있다.
- 스프링은 이 문제를 해결하기 위해 부가 기능을 적용할 때 Advice 라는 새로운 개념을 도입했다. 개발자는 InvocationHandler 나 MethodInterceptor 를 신경쓰지 않고, Advice 만 만들면 된다.
- 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은 Pointcut 이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

### 64. 프록시 팩토리 - 예제 코드1

- Advice 는 프록시에 적용하는 부가 기능 로직이다.
  - JDK 동적 프록시-InvocationHandler 와 CGLIB-MethodInterceptor 둘을 개념적으로 추상화 한 것이다.
- 스프링의 MethodInterceptor를 상속받아 구현
  - CGLIB의 MethodInterceptor 와 이름이 같으므로 패키지 이름에 주의하자

### 65. 프록시 팩토리 - 예제 코드2

- 프록시 팩토리는 인터페이스 없이 구체 클래스만 있으면 CGLIB를 사용해서 프록시를 적용한다.
- 프록시 팩토리는 proxyTargetClass 라는 옵션을 제공하는데, 이 옵션에 true 값을 넣으면 인터페이스가 있어도 강제로 CGLIB를 사용한다.

- 프록시 팩토리의 서비스 추상화 덕분에 구체적인 CGLIB, JDK 동적 프록시 기술에 의존하지 않고, 매우 편리하게 동적 프록시를 생성할 수 있다.
- 프록시의 부가 기능 로직도 특정 기술에 종속적이지 않게 Advice 하나로 편리하게 사용할 수 있었다.
  - 이것은 프록시 팩토리가 내부에서 JDK 동적 프록시인 경우 InvocationHandler 가 Advice 를 호출하도록 개발해두고, CGLIB인 경우 MethodInterceptor 가 Advice 를 호출하도록 기능을 개발해두었기 때문이다.
- **스프링 부트는 AOP를 적용할 때 기본적으로 proxyTargetClass=true 로 설정해서 사용한다.**

### 66. 포인트컷, 어드바이스, 어드바이저 - 소개

- 포인트컷( Pointcut ): 어디에 부가 기능을 적용할지, 적용하지 않을지 판단하는 **필터링 로직이다**.
  - 주로 클래스와 메서드 이름으로 필터링 한다.
  - 어떤 포인트(Point)에 기능을 적용할지 하지 않을지 잘라서(cut) 구분하는 것이다.
- 어드바이스( Advice ): 이전에 본 것 처럼 프록시가 호출하는 부가 기능이다. **단순하게 프록시 로직이라 생각하면 된다.**
- 어드바이저(Advisor): 단순하게 하나의 포인트컷과 하나의 어드바이스를 가지고 있는 것이다.

  - 쉽게 이야기해서 포인트컷1 + 어드바이스1이다.

- 조언자( Advisor )는 어디( Pointcut )에 조언( Advice )을 해야할지 알고 있다.
- 이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.
- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.
- 어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
- 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다. 둘을 합치면 어드바이저가 된다.

### 67. 예제 코드1 - 어드바이저

- new DefaultPointcutAdvisor : Advisor 인터페이스의 가장 일반적인 구현체이다. 생성자를 통해 하나의 포인트컷과 하나의 어드바이스를 넣어주면 된다. -
- proxyFactory.addAdvisor(advisor) : 프록시 팩토리에 적용할 어드바이저를 지정한다.
- 프록시 팩토리를 사용할 때 어드바이저는 필수이다.

- ProxyFactory는 내부에 어드바이저 목록(List)을 가지고 addAdvisor()를 호출할 때마다 이 목록에 어드바이저가 차곡차곡 쌓이는 구조
- getProxy()를 호출하는 시점에, ProxyFactory는 자기가 가지고 있는 모든 어드바이저를 적용한 프록시 객체를 딱 한 번에 만들어서 반환

### 68. 예제 코드2 - 직접 만든 포인트컷

- Pointcut 인터페이스를 구현한다.
- 포인트컷이 true 를 반환한다. 따라서 어드바이스를 호출해서 부가 기능을 적용한다.
- false는 어드바이스를 호출하지 않고, 부가 기능도 적용되지 않는다.

### 69. 예제 코드3 - 스프링이 제공하는 포인트컷

- 스프링은 무수히 많은 포인트컷을 제공한다. 대표적인 몇가지만 알아보자.

- NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils 를 사용한다.
- JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.
- TruePointcut : 항상 참을 반환한다.
- AnnotationMatchingPointcut : 애노테이션으로 매칭한다.
- AspectJExpressionPointcut : aspectJ 표현식으로 매칭한다.

- 사실 다른 것은 중요하지 않다. **실무에서는 사용하기도 편리하고 기능도 가장 많은 aspectJ 표현식을 기반으로 사용하는 AspectJExpressionPointcut을 사용**하게 된다.

### 70. 예제 코드4 - 여러 어드바이저 함께 적용

- 스프링은 AOP를 적용할 때, 최적화를 진행해서 지금처럼 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용한다.
- **하나의 target 에 여러 AOP가 동시에 적용되어도, 스프링의 AOP는 target 마다 하나의 프록시만 생성한다. 이부분을 꼭 기억해두자.**

- **스프링 AOP 프록시는 타겟 빈 하나당 단 하나의 싱글톤 객체로 생성됩니다.**
- 이 싱글톤 프록시는 애플리케이션이 실행되는 동안 계속 재사용되며 모든 요청을 처리합니다.
- 여러 AOP 로직(어드바이스)은 하나의 프록시 안에 체인(chain) 형태로 모두 포함되어 있습니다.

#### 타겟 클래스를 대상으로한 포인트컷으로 메서드를 제한하는건가?

- 1단계: 클래스 레벨 필터링 (타겟 빈 식별)
  - 포인트컷은 먼저 어떤 **클래스(빈)**가 AOP 적용 대상인지를 결정합니다.
  - within(*..*Service) 같은 표현식을 사용하면 "Service로 끝나는 모든 클래스"를 타겟으로 삼습니다.
- 2단계: 메서드 레벨 필터링 (조인 포인트 식별)
  - 클래스가 타겟으로 정해지면, 포인트컷은 그 클래스 내부의 어떤 메서드에 부가 기능을 적용할지를 다시 한번 필터링합니다.

#### 이러면 타켓 클래스를 전부 프록시팩토리에 넣어줘야 하는데?

- 수동 방식처럼 직접 코드를 짠다면, 사용자 말씀처럼 타겟이 되는 빈 100개에 대해 ProxyFactory를 100번 생성해서 프록시를 만들어야 하는 게 맞습니다.
- 하지만 스프링은 이 과정을 완전히 자동화합니다.
- 자동화의 핵심에는 **빈 후처리기(BeanPostProcessor)**라는 매우 중요한 개념이 있습니다.

- 빈 후처리기'라는 자동화 전문가
- 빈 후처리기는 스프링 컨테이너가 만드는 모든 빈에 대해 일종의 '검문'을 하는 특별한 빈입니다.
- 스프링 AOP에서는 AnnotationAwareAspectJAutoProxyCreator라는 빈 후처리기가 이 모든 작업을 자동으로 처리합니다.

동작 과정:

1. 스프링 컨테이너가 설정 정보를 읽어 UserService 같은 일반 빈을 생성합니다.
2. 생성된 빈 객체를 컨테이너에 등록하기 직전에, 빈 후처리기가 이 객체를 가로챕니다.
3. 빈 후처리기는 자기가 알고 있는 모든 Advisor(포인트컷 + 어드바이스)들을 꺼내봅니다.
4. 가로챈 빈(UserService)이 Advisor의 포인트컷 조건에 맞는지 자동으로 검사합니다.
5. 만약 조건에 맞다면 (타겟 빈이라면): 빈 후처리기가 내부적으로 ProxyFactory를 사용해 프록시 객체를 생성합니다. 그리고 원래의 UserService 객체 대신 생성된 프록시 객체를 스프링 컨테이너에 등록합니다.
6. 만약 조건에 맞지 않는다면: 아무런 작업도 하지 않고 원래의 객체를 그대로 스프링 컨테이너에 등록합니다.

- **결론적으로, 개발자는 ProxyFactory를 단 한 번도 직접 다룰 필요가 없습니다.**
- 그저 **@Aspect나 Advisor를 빈으로 등록해 '규칙'만 만들어두면, '빈 후처리기'라는 전문가가 모든 빈의 생성 과정을 일일이 검사하며 알아서 프록시를 만들어주는 것**입니다.

#### 그러면 하나의 어드바이저를 타겟 클래스가 여러개로 등록됐다면 클래스 수만큼 프록시 객체가 생성되나?

- 하나의 어드바이저(Advisor)가 여러 타겟 클래스(빈)에 적용된다면, 그 조건에 맞는 타겟 클래스의 수만큼 프록시 객체가 각각 생성됩니다.

- 스프링 AOP에서 프록시는 타겟 빈(Target Bean)을 기준으로 1:1로 생성되기 때문입니다.

### 71. 프록시 팩토리 - 적용1

### 72. 프록시 팩토리 - 적용2

### 73. 정리

- 프록시 팩토리 덕분에 개발자는 매우 편리하게 프록시를 생성할 수 있게 되었다.
- 추가로 어드바이저, 어드바이스, 포인트컷 이라는 개념 덕분에 어떤 부가 기능을 어디에 적용할 지 명확하게 이해할 수 있었다.

- 남은 문제
- 문제1 - 너무 많은 설정
- 바로 ProxyFactoryConfigV1 , ProxyFactoryConfigV2 와 같은 설정 파일이 지나치게 많다는 점이다.

  - 예를 들어서 애플리케이션에 스프링 빈이 100개가 있다면 여기에 프록시를 통해 부가 기능을 적용하려면 100개의 동적 프록시 생성 코드를 만들어야 한다! 무수히 많은 설정 파일 때문에 설정 지옥을 경험하게 될 것이다.
  - 최근에는 스프링 빈을 등록하기 귀찮아서 컴포넌트 스캔까지 사용하는데, 이렇게 직접 등록하는 것도 모자라서, 프록시를 적용하는 코드까지 빈 생성 코드에 넣어야 한다.

- 문제2 - 컴포넌트 스캔

  - 애플리케이션 V3처럼 컴포넌트 스캔을 사용하는 경우 지금까지 학습한 방법으로는 프록시 적용이 불가능하다.
  - 왜냐하면 실제 객체를 컴포넌트 스캔으로 스프링 컨테이너에 스프링 빈으로 등록을 다 해버린 상태이기 때문이다.
  - 지금까지 학습한 프록시를 적용하려면, 실제 객체를 스프링 컨테이너에 빈으로 등록하는 것이 아니라 ProxyFactoryConfigV1 에서 한 것 처럼, **부가 기능이 있는 프록시를 실제 객체 대신 스프링 컨테이너에 빈으로 등록해야 한다.**

- 두 가지 문제를 한번에 해결하는 방법이 바로 다음에 설명할 빈 후처리기이다.

## 8. 빈 후처리기

### 74. 빈 후처리기 - 소개

- 빈 후처리기 - BeanPostProcessor
- @Bean 이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성하고 스프링 컨테이너 내부의 빈 저장소에 등록한다.

- 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후처리기를 사용하면 된다.
- 객체를 조작할 수도 있고, 완전히 다른 객체로 바꿔치기 하는 것도 가능하다.

1. 생성: 스프링 빈 대상이 되는 객체를 생성한다. ( @Bean , 컴포넌트 스캔 모두 포함)
2. 전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 후 처리 작업: 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바뀌치기 할 수 있다.
4. 등록: 빈 후처리기는 빈을 반환한다. 전달 된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면 다른 객체가 빈 저장소에 등록된다.

### 75. 빈 후처리기 - 예제 코드1

### 76. 빈 후처리기 - 예제 코드2

- 일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이 없는데, 빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다.
- 이 말은 빈 객체를 프록시로 교체하는 것도 가능하다는 뜻이다.

- @PostConstruct 는 스프링 빈 생성 이후에 빈을 초기화 하는 역할을 한다.
- 스프링은 CommonAnnotationBeanPostProcessor 라는 빈 후처리기를 자동으로 등록하는데, 여기에서 @PostConstruct 애노테이션이 붙은 메서드를 호출한다.
- 스프링 스스로도 스프링 내부의 기능을 확장하기 위해 빈 후처리기를 사용한다.

### 77. 빈 후처리기 - 적용

- 빈 후처리기를 사용하면 컴포넌트 스캔을 사용하는 빈까지 모두 프록시를 적용하여 설정 파일에 있는 수 많은 프록시 생성 코드도 한번에 제거할 수 있다.

- 우리가 직접 등록한 스프링 빈들 뿐만 아니라 스프링 부트가 기본으로 등록하는 수 많은 빈들이 빈 후처리기에 넘어온다. 그래서 어떤 빈을 프록시로 만들 것인지 기준이 필요하다.
- 여기서는 간단히 basePackage 를 사용해서 특정 패키지를 기준으로 해당 패키지와 그 하위 패키지의 빈들을 프록시로 만든다.
- 스프링 부트가 기본으로 제공하는 빈 중에는 프록시 객체를 만들 수 없는 빈들도 있다.
  - 따라서 모든 객체를 프록시로 만들 경우 오류가 발생한다.

### 78. 빈 후처리기 - 정리

- 빈 후처리기 덕분에 프록시를 생성하는 부분을 하나로 집중할 수 있다.
- 컴포넌트 스캔처럼 스프링이 직접 대상을 빈으로 등록하는 경우에도 중간에 빈 등록 과정을 가로채서 원본 대신에 프록시를 스프링 빈으로 등록할 수 있다.
- 스프링은 프록시를 생성하기 위한 빈 후처리기를 이미 만들어서 제공한다.

- 포인트컷은 이미 클래스, 메서드 단위의 필터 기능을 가지고 있기 때문에, 프록시 적용 대상 여부를 정밀하게 설정할 수 있다.
- 참고로 어드바이저는 포인트컷을 가지고 있다. 따라서 어드바이저를 통해 포인트컷을 확인할 수 있다.
- 스프링 AOP는 포인트컷을 사용해서 프록시 적용 대상 여부를 체크한다.
- 결과적으로 포인트컷은 다음 두 곳에 사용된다.
  1. 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다. (빈 후처리기 - 자동 프록시 생성)
  2. 프록시의 어떤 메서드가 호출 되었을 때 어드바이스를 적용할 지 판단한다. (프록시 내부)

#### 포인트컷을 사용하려면 일단 생성된 어드바이저를 타켓에 등록해야하는거 아닌가?

- 수동 AOP와 스프링 AOP의 가장 큰 차이점
- **개발자가 타겟을 어드바이저에 등록하는 것이 아니라, 스프링이 어드바이저의 포인트컷을 보고 타겟을 알아서 찾아냅니다**.

### 79. 스프링이 제공하는 빈 후처리기1

- `implementation 'org.springframework.boot:spring-boot-starter-aop' `
- 스프링 부트가 AOP 관련 클래스를 자동으로 스프링 빈에 등록한다.

- 자동 프록시 생성기 - AutoProxyCreator
- 스프링 부트 자동 설정으로 `AnnotationAwareAspectJAutoProxyCreator` 라는 빈 후처리기가 스프링 빈에 자동으로 등록된다.
  - 스프링 빈으로 등록된 Advisor 들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용해준다.
- `AnnotationAwareAspectJAutoProxyCreator` 는 `@AspectJ`와 관련된 AOP 기능도 자동으로 찾아서 처리해준다.
- `Advisor` 는 물론이고, `@Aspect`도 자동으로 인식해서 프록시를 만들고 AOP를 적용해준다.

- 자동 프록시 생성기의 작동 과정

1. 생성: 스프링이 스프링 빈 대상이 되는 객체를 생성한다. ( @Bean , 컴포넌트 스캔 모두 포함)
2. 전달: 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 모든 Advisor 빈 조회: 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 Advisor 를 조회한다.
4. 프록시 적용 대상 체크: 앞서 조회한 Advisor 에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다. 이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용 대상이 된다.
5. 프록시 생성: 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면 원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
6. 빈 등록: 반환된 객체는 스프링 빈으로 등록된다.

### 80. 스프링이 제공하는 빈 후처리기2

- AspectJExpressionPointcut: AspectJ라는 AOP에 특화된 포인트컷 표현식을 적용할 수 있다.

- AspectJExpressionPointcut : AspectJ 포인트컷 표현식을 적용할 수 있다.
- `execution(* hello.proxy.app..*(..))` : AspectJ가 제공하는 포인트컷 표현식이다.
- hello.proxy.app 패키지와 그 하위 패키지의 모든 메서드는 포인트컷의 매칭 대상이 된다.
- \* : 모든 반환 타입
- hello.proxy.app.. : 해당 패키지와 그 하위 패키지
- \*(..) : \* 모든 메서드 이름, (..) 파라미터는 상관 없음

### 81. 하나의 프록시, 여러 Advisor 적용

- 프록시 자동 생성기는 프록시를 하나만 생성한다. 왜냐하면 프록시 팩토리가 생성하는 프록시는 내부에 여러 advisor 들을 포함할 수 있기 때문이다.
- 따라서 프록시를 여러 개 생성해서 비용을 낭비할 이유가 없다.

### 82. 정리

- Advisor = Pointcut + Advice

## 9. @Aspect AOP

### 83. @Aspect 프록시 - 적용

- 스프링은 @Aspect 애노테이션으로 매우 편리하게 포인트컷과 어드바이스로 구성되어 있는 어드바이저 생성 기능을 지원한다.

- `@Aspect` : 애노테이션 기반 프록시를 적용할 때 필요하다.
- `@Around("execution(* hello.proxy.app..*(..))")`
- `@Around` 의 값에 포인트컷 표현식을 넣는다. 표현식은 AspectJ 표현식을 사용한다.
- `@Around` 의 메서드는 어드바이스( Advice )가 된다.
- `ProceedingJoinPoint joinPoint` : 어드바이스에서 살펴본 MethodInvocation invocation 과 유사한 기능이다. 내부에 실제 호출 대상, 전달 인자, 그리고 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함 되어 있다.
- `joinPoint.proceed()` : 실제 호출 대상( target )을 호출한다.

### 84. @Aspect 프록시 - 설명

- 자동 프록시 생성기는 여기에 추가로 하나의 역할을 더 하는데, **바로 @Aspect 를 찾아서 이것을 Advisor 로 만들어준다**
- 그래서 이름 앞에 AnnotationAware (애노테이션을 인식하는)가 붙어 있는 것이다.

### 85. 정리

- 실무에서 프록시를 적용할 때는 대부분 이 이 방식을 사용한다.
- 지금까지 우리가 진행한 애플리케이션 전반에 로그를 남기는 기능은 특정 기능 하나에 관심이 있는 기능이 아니다.
- 애플리케이션의 여러 기능들 사이에 걸쳐서 들어가는 관심사이다.
- 이것을 바로 횡단 관심사(cross-cutting concerns)라고 한다.
- 우리가 지금까지 진행한 방법이 이렇게 여러곳에 걸쳐 있는 횡단 관심사의 문제를 해결하는 방법이었다.

## 10. 스프링 AOP 개념

### 86. AOP 소개 - 핵심 기능과 부가 기능

### 87. AOP 소개 - 애스펙트

### 88. AOP 적용 방식

### 89. AOP 용어 정리

### 90. 정리

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

### 95. 스프링 AOP 구현3 - 어드바이스 추가

### 96. 스프링 AOP 구현4 - 포인트컷 참조

### 97. 스프링 AOP 구현5 - 어드바이스 순서

### 98. 스프링 AOP 구현6 - 어드바이스 종류

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리

## 15. 다음으로

### 125. 다음으로
