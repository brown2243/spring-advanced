# [스프링 핵심 원리 - 고급편](../)

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

- @Aspect 를 사용하려면 @EnableAspectJAutoProxy 를 스프링 설정에 추가해야 하지만, 스프링 부트를 사용하면 자동으로 추가된다.

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

- **@Pointcut 에 포인트컷 표현식을 사용한다.**
- **메서드 이름과 파라미터를 합쳐서 포인트컷 시그니처(signature)라 한다.**
- 메서드의 반환 타입은 void 여야 한다.
- 코드 내용은 비워둔다.
- @Around 어드바이스에서는 포인트컷을 직접 지정해도 되지만, 포인트컷 시그니처를 사용해도 된다.
  - 여기서는 @Around("allOrder()")를 사용한다.
- 접근 제어자는 내부에서만 사용하면 private, 다른 애스팩트에서 참고하려면 public

### 95. 스프링 AOP 구현3 - 어드바이스 추가

- 앞서 로그를 출력하는 기능에 추가로 트랜잭션을 적용하는 코드도 추가해보자.
- 여기서는 진짜 트랜잭션을 실행하는 것은 아니다. 기능이 동작한 것 처럼 로그만 남기겠다.

- 트랜잭션 기능은 보통 다음과 같이 동작한다.

  - 핵심 로직 실행 직전에 트랜잭션을 시작
  - 핵심 로직 실행
  - 핵심 로직 실행에 문제가 없으면 커밋
  - 핵심 로직 실행에 예외가 발생하면 롤백

- 포인트컷은 이렇게 조합할 수 있다. && (AND), || (OR), ! (NOT) 3가지 조합이 가능하다.

### 96. 스프링 AOP 구현4 - 포인트컷 참조

- 포인트컷을 공용으로 사용하기 위해 별도의 외부 클래스에 모아두어도 된다.

### 97. 스프링 AOP 구현5 - 어드바이스 순서

- `org.springframework.core.annotation.@Order` 애노테이션을 적용해야 한다.
- 문제는 이것을 어드바이스 단위가 아니라 클래스 단위로 적용할 수 있다는 점이다.
- **그래서 지금처럼 하나의 애스펙트에 여러 어드바이스가 있으면 순서를 보장 받을 수 없다.**
- 따라서 애스펙트를 별도의 클래스로 분리해야 한다.

### 98. 스프링 AOP 구현6 - 어드바이스 종류

- 어드바이스 종류

  - `@Around` : 메서드 호출 전후에 수행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
    - 어드바이스의 첫 번째 파라미터는 ProceedingJoinPoint 를 사용해야 한다.
  - `@Before` : 조인 포인트 실행 이전에 실행
    - 작업 흐름을 변경할 수는 없다.
  - `@AfterReturning` : 조인 포인트가 정상 완료후 실행
    - 반환되는 객체를 변경할 수는 없다.
  - `@AfterThrowing` : 메서드가 예외를 던지는 경우 실행
  - `@After` : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)
    - 메서드 실행이 종료되면 실행된다.

- 모든 어드바이스는 org.aspectj.lang.JoinPoint 를 첫번째 파라미터에 사용할 수 있다. (생략해도 된다.)
- **단 @Around 는 ProceedingJoinPoint 을 사용해야 한다.**
- JoinPoint 인터페이스의 주요 기능
  - `getArgs()` : 메서드 인수를 반환합니다.
  - `getThis()` : 프록시 객체를 반환합니다.
  - `getTarget()` : 대상 객체를 반환합니다.
  - `getSignature()` : 조언되는 메서드에 대한 설명을 반환합니다.
  - `toString()` : 조언되는 방법에 대한 유용한 설명을 인쇄합니다.
- ProceedingJoinPoint 인터페이스의 주요 기능

  - `proceed()` : 다음 어드바이스나 타켓을 호출한다.

- 스프링은 5.2.7 버전부터 동일한 @Aspect 안에서 동일한 조인포인트의 우선순위를 정했다.
- 실행 순서: @Around , @Before , @After , @AfterReturning , @AfterThrowing
- 어드바이스가 적용되는 순서는 이렇게 적용되지만, 호출 순서와 리턴 순서는 반대라는 점을 알아두자.
- 물론 @Aspect 안에 동일한 종류의 어드바이스가 2개 있으면 순서가 보장되지 않는다.
- 이 경우 앞서 배운 것 처럼 @Aspect 를 분리하고 @Order 를 적용하자.

- @Around 가 가장 넓은 기능을 제공하는 것은 맞지만, 실수할 가능성이 있다.
- 반면에 @Before , @After 같은 어드바이스는 기능은 적지만 실수할 가능성이 낮고, 코드도 단순하다.
- 가장 중요한 점은 바로 이 코드를 작성한 의도가 명확하게 드러난다는 점이다.

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

- 포인트컷 표현식은 AspectJ pointcut expression 애스펙트J가 제공하는 포인트컷 표현식을 줄여서 말하는 것이다.
- execution 같은 포인트컷 지시자(Pointcut Designator)로 시작한다. 줄여서 PCD라 한다.

- 포인트컷 지시자의 종류

  - **execution : 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡하다.**
  - within : 특정 타입 내의 조인 포인트를 매칭한다.
  - args : 인자가 주어진 타입의 인스턴스인 조인 포인트
  - this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
  - target : Target 객체(스프링 AOP 프록시가 가리키는 실제 대상)를 대상으로 하는 조인 포인트
  - @target : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
  - @within : 주어진 애노테이션이 있는 타입 내 조인 포인트
  - @annotation : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭
  - @args : 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
  - bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정한다.

- **execution 은 가장 많이 사용하고, 나머지는 자주 사용하지 않는다. 따라서 execution 을 중점적으로 이해하자.**

### 101. 예제 만들기

- AspectJExpressionPointcut 이 바로 포인트컷 표현식을 처리해주는 클래스다.
- AspectJExpressionPointcut 는 상위에 Pointcut 인터페이스를 가진다.

### 102. execution - 1

```java
// execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?)
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
```

- 메소드 실행 조인 포인트를 매칭한다.
- ?는 생략할 수 있다.
- \* 같은 패턴을 지정할 수 있다.
- 패키지에서 . , .. 의 차이를 이해해야 한다.
- . : 정확하게 해당 위치의 패키지
- .. : 해당 위치의 패키지와 그 하위 패키지도 포함

### 103. execution - 2

- execution 파라미터 매칭 규칙은 다음과 같다.
- (String) : 정확하게 String 타입 파라미터
- () : 파라미터가 없어야 한다.
- (\*) : 정확히 하나의 파라미터, 단 모든 타입을 허용한다.
- (_, _) : 정확히 두 개의 파라미터, 단 모든 타입을 허용한다.
- (..) : 숫자와 무관하게 모든 파라미터, 모든 타입을 허용한다. 참고로 파라미터가 없어도 된다. 0..\* 로 이해하
- 면 된다.
- (String, ..) : String 타입으로 시작해야 한다. 숫자와 무관하게 모든 파라미터, 모든 타입을 허용한다.

### 104. within

- within 지시자는 특정 타입 내의 조인 포인트들로 매칭을 제한한다.
- 쉽게 이야기해서 해당 타입이 매칭되면 그 안의 메서드(조인 포인트)들이 자동으로 매칭된다.
- 표현식에 부모 타입을 지정하면 안된다 정확하게 타입이 맞아야 한다.

### 105. args

args : 인자가 주어진 타입의 인스턴스인 조인 포인트로 매칭
args는 메서드 호출 시 전달되는 '실제 객체'의 런타임 타입을 보고 동적으로 매칭해요.
반면 execution은 '메서드 시그니처'의 선언된 타입만 보고 정적으로 매칭한답니다.

### 106. @target, @within

@target : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
@within : 주어진 애노테이션이 있는 타입 내 조인 포인트

### 107. @annotation, @args

@annotation : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트를 매칭

### 108. bean

bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 지정한다.

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

스프링이 제공하는 @Transactional 은 가장 대표적인 AOP이다.

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

- AOP를 적용하려면 항상 프록시를 통해서 대상 객체(Target)을 호출해야 한다.
- 이렇게 해야 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.

- **하지만 대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.**
- 실무에서 반드시 한번은 만나서 고생하는 문제이기 때문에 꼭 이해하고 넘어가자.

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

- 스프링에서 AOP가 적용된 대상을 의존관계 주입 받으면 주입 받은 대상은 실제 자신이 아니라 프록시 객체이다.
- 따라서 프록시를 통해서 AOP를 적용할 수 있다.
- 참고로 이 경우 생성자 주입시 오류가 발생한다. 본인을 생성하면서 주입해야 하기 때문에 순환 사이클이 만들어진다.
- 반면에 수정자 주입은 스프링이 생성된 이후에 주입할 수 있기 때문에 오류가 발생하지 않는다.
  - 수정자 주입은 해당 빈을 발견하면, 스프링이 리플렉션으로 이 메서드를 직접 호출해서 주입
  - 즉, 우리가 코드에서 수동으로 setCallServiceV1()을 호출하지 않아도 됨
  - 이 과정은 빈 생성 시점(즉, @Component 스캔 → 인스턴스 생성 → 의존성 주입 단계)에서 자동 실행됨

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

- **가장 나은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다. 실제 이 방법을 가장 권장한다.**
- AOP는 주로 트랜잭션 적용이나 주요 컴포넌트의 로그 출력 기능에 사용된다.
- 쉽게 이야기해서 인터페이스에 메서드가 나올 정도의 규모에 AOP를 적용하는 것이 적당하다.
- **더 풀어서 이야기하면 AOP는 public 메서드에만 적용한다. private 메서드처럼 작은 단위에는 AOP를 적용하지 않는다.**
- AOP 적용을 위해 private 메서드를 외부 클래스로 변경하고 public 으로 변경하는 일은 거의 없다.
- 그러나 위 예제와 같이 public 메서드에서 public 메서드를 내부 호출하는 경우에는 문제가 발생한다.

### 120. 프록시 기술과 한계 - 타입 캐스팅

- JDK 동적 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 없다.
- CGLIB 프록시는 대상 객체인 MemberServiceImpl 로 캐스팅 할 수 있다.

### 121. 프록시 기술과 한계 - 의존관계 주입

- JDK 동적 프록시는 대상 객체인 MemberServiceImpl 타입에 의존관계를 주입할 수 없다.
- CGLIB 프록시는 대상 객체인 MemberServiceImpl 타입에 의존관계 주입을 할 수 있다.

- MemberServiceImpl 타입으로 의존관계 주입을 받는 것 처럼 구현 클래스에 의존관계를 주입하면 향후 구현 클래스를 변경할 때 의존관계 주입을 받는 클라이언트의 코드도 함께 변경해야 한다.
- DI의 장점이 무엇인가? DI 받는 클라이언트 코드의 변경 없이 구현 클래스를 변경할 수 있는 것이다.
- 이렇게 하려면 인터페이스를 기반으로 의존관계를 주입 받아야 한다.

- 테스트, 또는 여러가지 이유로 AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입 받아야 하는 경우가 있을 수 있다.
- 이때는 CGLIB를 통해 구체 클래스 기반으로 AOP 프록시를 적용하면 된다.

### 122. 프록시 기술과 한계 - CGLIB

- CGLIB 구체 클래스 기반 프록시 문제점
  - 대상 클래스에 기본 생성자 필수
  - 생성자 2번 호출 문제
  - final 키워드 클래스, 메서드 사용 불가

#### 대상 클래스에 기본 생성자 필수

- CGLIB는 구체 클래스를 상속 받는다.
- 자바 언어에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야 한다.
  - 이 부분이 생략되어 있다면 자식 클래스의 생성자 첫줄에 부모 클래스의 기본 생성자를 호출하는 super() 가 자동으로 들어간다.
  - 이 부분은 자바 문법 규약이다.
- CGLIB를 사용할 때 CGLIB가 만드는 프록시의 생성자는 우리가 호출하는 것이 아니다.
- CGLIB 프록시는 대상 클래스를 상속 받고, 생성자에서 대상 클래스의 기본 생성자를 호출한다. 따라서 대상 클래스에 기본 생성자를 만들어야 한다.

#### 생성자 2번 호출 문제

- CGLIB는 구체 클래스를 상속 받는다.
- 자바 언어에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 부모 클래스의 생성자도 호출해야 한다. 그런데 왜 2번일까?
  1. 실제 target의 객체를 생성할 때
  2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출

#### final 키워드 클래스, 메서드 사용 불가

- final 키워드가 클래스에 있으면 상속이 불가능하고, 메서드에 있으면 오버라이딩이 불가능하다.
- CGLIB는 상속을 기반으로 하기 때문에 두 경우 프록시가 생성되지 않거나 정상 동작하지 않는다.
- 프레임워크 같은 개발이 아니라 일반적인 웹 애플리케이션을 개발할 때는 final 키워드를 잘 사용하지 않는다.

정리
JDK 동적 프록시는 대상 클래스 타입으로 주입할 때 문제가 있고, CGLIB는 대상 클래스에 기본 생성자 필수, 생성자 2
번 호출 문제가 있다.

그렇다면 스프링은 어떤 방법을 권장할까?

### 123. 프록시 기술과 한계 - 스프링의 해결책

- 스프링은 CGLIB 라이브러리를 스프링 내부에 함께 패키징해서 별도의 라이브러리 추가 없이 CGLIB를 사용할 수 있게 되었다.
- CGLIB 기본 생성자 필수 문제 해결

  - **스프링 4.0부터 CGLIB의 기본 생성자가 필수인 문제가 해결되었다.**
  - objenesis 라는 특별한 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하다.
  - 참고로 이 라이브러리는 생성자 호출 없이 객체를 생성할 수 있게 해준다.

- 생성자 2번 호출 문제

  - 스프링 4.0부터 CGLIB의 생성자 2번 호출 문제가 해결되었다.
  - 이것도 역시 objenesis 라는 특별한 라이브러리 덕분에 가능해졌다.
  - 이제 생성자가 1번만 호출된다.

- 스프링 부트 2.0 - CGLIB 기본 사용

  - 스프링 부트 2.0 버전부터 CGLIB를 기본으로 사용하도록 했다.
  - 이렇게 해서 구체 클래스 타입으로 의존관계를 주입하는 문제를 해결했다.
  - 따라서 인터페이스가 있어도 JDK 동적 프록시를 사용하는 것이 아니라 항상 CGLIB를 사용해서 구체클래스를 기반으로 프록시를 생성한다.

- 개발자 입장에서 보면 사실 어떤 프록시 기술을 사용하든 상관이 없다.
- JDK 동적 프록시든 CGLIB든 또는 어떤 새로운 프록시 기술을 사용해도 된다.
- 심지어 클라이언트 입장에서 어떤 프록시 기술을 사용하는지 모르고 잘 동작하는 것이 가장 좋다.
- 단지 문제 없고, 개발하기에 편리하면 되는 것이다.

### 124. 정리
