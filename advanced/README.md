# [스프링 핵심 원리 - 고급편](../)

## 2. 예제 만들기

### 4. 프로젝트 생성

### 5. 예제 프로젝트 만들기 - V0

- 백엔드 기본 흐름 예제 구현

### 6. 로그 추적기 - 요구사항 분석

### 7. 로그 추적기 V1 - 프로토타입 개발

### 8. 로그 추적기 V1 - 적용

- trace.exception() 으로 예외까지 처리해야 하므로 지저분한 try , catch 코드가 추가된다.
- 예외를 꼭 다시 던져 흐름을 막지말자

- 아직 구현하지 못한 요구사항은 메서드 호출의 깊이를 표현하고, 같은 HTTP 요청이면 같은 트랜잭션 ID를 남기는 것 이다.
- 이 기능은 직전 로그의 깊이와 트랜잭션 ID가 무엇인지 알아야 할 수 있는 일이다.
- 결국 현재 로그의 상태 정보인 트랜잭션ID 와 level 이 다음으로 전달되어야 한다.
- **정리하면 로그에 대한 문맥( Context ) 정보가 필요하다.**

### 9. 로그 추적기 V2 - 파라미터로 동기화 개발

### 10. 로그 추적기 V2 - 적용

### 11. 정리

- 드디어 모든 요구사항을 만족했다.

- 하지만 남은 문제

  - HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 동기화가 필요하다.
  - **TraceId 의 동기화를 위해서 관련 메서드의 모든 파라미터를 수정해야 한다.**
  - 만약 인터페이스가 있다면 인터페이스까지 모두 고쳐야 하는 상황이다.
  - 로그를 처음 시작할 때는 begin() 을 호출하고, 처음이 아닐때는 beginSync() 를 호출해야 한다.
  - 만약에 컨트롤러를 통해서 서비스를 호출하는 것이 아니라, 다른 곳에서 서비스를 처음으로 호출하는 상황이라면 파리미터로 넘길 TraceId 가 없다.

- **HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 를 파라미터로 넘기는 것 말고 다른 대안은 없을까?**

- 이 예제를 작성하며 느낀건데, 트랜잭션 id를 분리한다는 개념이 클라이언트에서 없는 것 같다.

## 3. 쓰레드 로컬 - ThreadLocal

### 12. 필드 동기화 - 개발

- 앞서 로그 추적기를 만들면서 다음 로그를 출력할 때 트랜잭션ID 와 level 을 동기화 하는 문제가 있었다.
  - 이 문제를 해결하기 위해 TraceId 를 파라미터로 넘기도록 구현했다.
- 이렇게 해서 동기화는 성공했지만, 로그를 출력하는 모든 메서드에 TraceId 파라미터를 추가해야 하는 문제가 발생했다.
- TraceId 를 동기화 하는 부분만 파라미터를 사용하는 것에서 TraceId traceIdHolder 필드를 사용하도록 변경되었다.

### 13. 필드 동기화 - 적용

### 14. 필드 동기화 - 동시성 문제

- 싱글톤 객체이고 여러 요청들이 공유하기에 동시성 문제가 생긴다.
- FieldLogTrace 는 싱글톤으로 등록된 스프링 빈이다.
- 하나만 있는 인스턴스의 FieldLogTrace.traceIdHolder 필드를 여러 쓰레드가 동시에 접근하기 때문에 문제가 발생한다.

### 15. 동시성 문제 - 예제 코드

- 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라 한다.
- 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하기 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 트래픽이 점점 많아질 수 록 자주 발생한다.
- 특히 스프링 빈 처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 한다.

- 이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다.
- 동시성 문제가 발생하는 곳은 같은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 또는 static 같은 공용 필드에 접근할 때 발생한다.
- 동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.

### 16. ThreadLocal - 소개

- 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공한다.
- 따라서 같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제 없다.
- 자바는 언어차원에서 쓰레드 로컬을 지원하기 위한 java.lang.ThreadLocal 클래스를 제공한다.

### 17. ThreadLocal - 예제 코드

- 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ThreadLocal.remove() 를 호출해서 쓰레드 로컬에 저장 된 값을 제거해주어야 한다. 제거하는 구체적인 예제는 조금 뒤에 설명하겠다.

### 18. 쓰레드 로컬 동기화 - 개발

### 19. 쓰레드 로컬 동기화 - 적용

### 20. 쓰레드 로컬 - 주의사항

- 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

- 사용자A 저장 요청
  1. 사용자A가 저장 HTTP를 요청했다.
  2. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
  3. 쓰레드 thread-A 가 할당되었다.
  4. thread-A 는 사용자A 의 데이터를 쓰레드 로컬에 저장한다.
  5. 쓰레드 로컬의 thread-A 전용 보관소에 사용자A 데이터를 보관한다.
- 사용자A 저장 요청 종료
  1. 사용자A의 HTTP 응답이 끝난다.
  2. WAS는 사용이 끝난 thread-A 를 쓰레드 풀에 반환한다. 쓰레드를 생성하는 비용은 비싸기 때문에 쓰레드를 제거하지 않고, 보통 쓰레드 풀을 통해서 쓰레드를 재사용한다.
  3. thread-A 는 쓰레드풀에 아직 살아있다. 따라서 쓰레드 로컬의 thread-A 전용 보관소에 사용자A 데이터도 함께 살아있게 된다.
- 사용자B 조회 요청

  1. 사용자B가 조회를 위한 새로운 HTTP 요청을 한다.
  2. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
  3. 쓰레드 thread-A 가 할당되었다. (물론 다른 쓰레드가 할당될 수 도 있다.)
  4. 이번에는 조회하는 요청이다. thread-A 는 쓰레드 로컬에서 데이터를 조회한다.
  5. 쓰레드 로컬은 thread-A 전용 보관소에 있는 사용자A 값을 반환한다.
  6. 결과적으로 사용자A 값이 반환된다.
  7. 사용자B는 사용자A의 정보를 조회하게 된다.

- **결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 심각한 문제가 발생하게 된다.**
- 쓰레드 로컬을 사용할 때는 이 부분을 꼭! 기억하자.

### 21. 정리

## 4. 템플릿 메서드 패턴과 콜백 패턴

### 22. 템플릿 메서드 패턴 - 시작

### 23. 템플릿 메서드 패턴 - 예제1

### 24. 템플릿 메서드 패턴 - 예제2

### 25. 템플릿 메서드 패턴 - 예제3

### 26. 템플릿 메서드 패턴 - 적용1

### 27. 템플릿 메서드 패턴 - 적용2

### 28. 템플릿 메서드 패턴 - 정의

### 29. 전략 패턴 - 시작

### 30. 전략 패턴 - 예제1

### 31. 전략 패턴 - 예제2

### 32. 전략 패턴 - 예제3

### 33. 템플릿 콜백 패턴 - 시작

### 34. 템플릿 콜백 패턴 - 예제

### 35. 템플릿 콜백 패턴 - 적용

### 36. 정리

## 5. 프록시 패턴과 데코레이터 패턴

### 37. 프로젝트 생성

### 38. 예제 프로젝트 만들기 v1

### 39. 예제 프로젝트 만들기 v2

### 40. 예제 프로젝트 만들기 v3

### 41. 요구사항 추가

### 42. 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

### 43. 프록시 패턴 - 예제 코드1

### 44. 프록시 패턴 - 예제 코드2

### 45. 데코레이터 패턴 - 예제 코드1

### 46. 데코레이터 패턴 - 예제 코드2

### 47. 데코레이터 패턴 - 예제 코드3

### 48. 프록시 패턴과 데코레이터 패턴 정리

### 49. 인터페이스 기반 프록시 - 적용

### 50. 구체 클래스 기반 프록시 - 예제1

### 51. 구체 클래스 기반 프록시 - 예제2

### 52. 구체 클래스 기반 프록시 - 적용

### 53. 인터페이스 기반 프록시와 클래스 기반 프록시

### 54. 정리

## 6. 동적 프록시 기술

### 55. 리플렉션

### 56. JDK 동적 프록시 - 소개

### 57. JDK 동적 프록시 - 예제 코드

### 58. JDK 동적 프록시 - 적용1

### 59. JDK 동적 프록시 - 적용2

### 60. CGLIB - 소개

### 61. CGLIB - 예제 코드

### 62. 정리

## 7. 스프링이 지원하는 프록시

### 63. 프록시 팩토리 - 소개

### 64. 프록시 팩토리 - 예제 코드1

### 65. 프록시 팩토리 - 예제 코드2

### 66. 포인트컷, 어드바이스, 어드바이저 - 소개

### 67. 예제 코드1 - 어드바이저

### 68. 예제 코드2 - 직접 만든 포인트컷

### 69. 예제 코드3 - 스프링이 제공하는 포인트컷

### 70. 예제 코드4 - 여러 어드바이저 함께 적용

### 71. 프록시 팩토리 - 적용1

### 72. 프록시 팩토리 - 적용2

### 73. 정리

## 8. 빈 후처리기

### 74. 빈 후처리기 - 소개

### 75. 빈 후처리기 - 예제 코드1

### 76. 빈 후처리기 - 예제 코드2

### 77. 빈 후처리기 - 적용

### 78. 빈 후처리기 - 정리

### 79. 스프링이 제공하는 빈 후처리기1

### 80. 스프링이 제공하는 빈 후처리기2

### 81. 하나의 프록시, 여러 Advisor 적용

### 82. 정리

## 9. @Aspect AOP

### 83. @Aspect 프록시 - 적용

### 84. @Aspect 프록시 - 설명

### 85. 정리

## 10. 스프링 AOP 개념

### 86. AOP 소개 - 핵심 기능과 부가 기능

### 87. AOP 소개 - 애스펙트

### 88. AOP 적용 방식

### 89. AOP 용어 정리

### 90. 정리

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

### 95. 스프링 AOP 구현3 - 어드바이스 추가

### 96. 스프링 AOP 구현4 - 포인트컷 참조

### 97. 스프링 AOP 구현5 - 어드바이스 순서

### 98. 스프링 AOP 구현6 - 어드바이스 종류

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리

## 15. 다음으로

### 125. 다음으로
