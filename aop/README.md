# [스프링 핵심 원리 - 고급편](../)

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

- @Aspect 를 사용하려면 @EnableAspectJAutoProxy 를 스프링 설정에 추가해야 하지만, 스프링 부트를 사용하면 자동으로 추가된다.

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

- **@Pointcut 에 포인트컷 표현식을 사용한다.**
- **메서드 이름과 파라미터를 합쳐서 포인트컷 시그니처(signature)라 한다.**
- 메서드의 반환 타입은 void 여야 한다.
- 코드 내용은 비워둔다.
- @Around 어드바이스에서는 포인트컷을 직접 지정해도 되지만, 포인트컷 시그니처를 사용해도 된다.
  - 여기서는 @Around("allOrder()")를 사용한다.
- 접근 제어자는 내부에서만 사용하면 private, 다른 애스팩트에서 참고하려면 public

### 95. 스프링 AOP 구현3 - 어드바이스 추가

- 앞서 로그를 출력하는 기능에 추가로 트랜잭션을 적용하는 코드도 추가해보자.
- 여기서는 진짜 트랜잭션을 실행하는 것은 아니다. 기능이 동작한 것 처럼 로그만 남기겠다.

- 트랜잭션 기능은 보통 다음과 같이 동작한다.

  - 핵심 로직 실행 직전에 트랜잭션을 시작
  - 핵심 로직 실행
  - 핵심 로직 실행에 문제가 없으면 커밋
  - 핵심 로직 실행에 예외가 발생하면 롤백

- 포인트컷은 이렇게 조합할 수 있다. && (AND), || (OR), ! (NOT) 3가지 조합이 가능하다.

### 96. 스프링 AOP 구현4 - 포인트컷 참조

- 포인트컷을 공용으로 사용하기 위해 별도의 외부 클래스에 모아두어도 된다.

### 97. 스프링 AOP 구현5 - 어드바이스 순서

- `org.springframework.core.annotation.@Order` 애노테이션을 적용해야 한다.
- 문제는 이것을 어드바이스 단위가 아니라 클래스 단위로 적용할 수 있다는 점이다.
- **그래서 지금처럼 하나의 애스펙트에 여러 어드바이스가 있으면 순서를 보장 받을 수 없다.**
- 따라서 애스펙트를 별도의 클래스로 분리해야 한다.

### 98. 스프링 AOP 구현6 - 어드바이스 종류

- 어드바이스 종류

  - `@Around` : 메서드 호출 전후에 수행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
    - 어드바이스의 첫 번째 파라미터는 ProceedingJoinPoint 를 사용해야 한다.
  - `@Before` : 조인 포인트 실행 이전에 실행
    - 작업 흐름을 변경할 수는 없다.
  - `@AfterReturning` : 조인 포인트가 정상 완료후 실행
    - 반환되는 객체를 변경할 수는 없다.
  - `@AfterThrowing` : 메서드가 예외를 던지는 경우 실행
  - `@After` : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)
    - 메서드 실행이 종료되면 실행된다.

- 모든 어드바이스는 org.aspectj.lang.JoinPoint 를 첫번째 파라미터에 사용할 수 있다. (생략해도 된다.)
- **단 @Around 는 ProceedingJoinPoint 을 사용해야 한다.**
- JoinPoint 인터페이스의 주요 기능
  - `getArgs()` : 메서드 인수를 반환합니다.
  - `getThis()` : 프록시 객체를 반환합니다.
  - `getTarget()` : 대상 객체를 반환합니다.
  - `getSignature()` : 조언되는 메서드에 대한 설명을 반환합니다.
  - `toString()` : 조언되는 방법에 대한 유용한 설명을 인쇄합니다.
- ProceedingJoinPoint 인터페이스의 주요 기능

  - `proceed()` : 다음 어드바이스나 타켓을 호출한다.

- 스프링은 5.2.7 버전부터 동일한 @Aspect 안에서 동일한 조인포인트의 우선순위를 정했다.
- 실행 순서: @Around , @Before , @After , @AfterReturning , @AfterThrowing
- 어드바이스가 적용되는 순서는 이렇게 적용되지만, 호출 순서와 리턴 순서는 반대라는 점을 알아두자.
- 물론 @Aspect 안에 동일한 종류의 어드바이스가 2개 있으면 순서가 보장되지 않는다.
- 이 경우 앞서 배운 것 처럼 @Aspect 를 분리하고 @Order 를 적용하자.

- @Around 가 가장 넓은 기능을 제공하는 것은 맞지만, 실수할 가능성이 있다.
- 반면에 @Before , @After 같은 어드바이스는 기능은 적지만 실수할 가능성이 낮고, 코드도 단순하다.
- 가장 중요한 점은 바로 이 코드를 작성한 의도가 명확하게 드러난다는 점이다.

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리
