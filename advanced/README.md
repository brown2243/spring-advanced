# [스프링 핵심 원리 - 고급편](../)

## 2. 예제 만들기

### 4. 프로젝트 생성

### 5. 예제 프로젝트 만들기 - V0

- 백엔드 기본 흐름 예제 구현

### 6. 로그 추적기 - 요구사항 분석

### 7. 로그 추적기 V1 - 프로토타입 개발

### 8. 로그 추적기 V1 - 적용

- trace.exception() 으로 예외까지 처리해야 하므로 지저분한 try , catch 코드가 추가된다.
- 예외를 꼭 다시 던져 흐름을 막지말자

- 아직 구현하지 못한 요구사항은 메서드 호출의 깊이를 표현하고, 같은 HTTP 요청이면 같은 트랜잭션 ID를 남기는 것 이다.
- 이 기능은 직전 로그의 깊이와 트랜잭션 ID가 무엇인지 알아야 할 수 있는 일이다.
- 결국 현재 로그의 상태 정보인 트랜잭션ID 와 level 이 다음으로 전달되어야 한다.
- **정리하면 로그에 대한 문맥( Context ) 정보가 필요하다.**

### 9. 로그 추적기 V2 - 파라미터로 동기화 개발

### 10. 로그 추적기 V2 - 적용

### 11. 정리

- 드디어 모든 요구사항을 만족했다.

- 하지만 남은 문제

  - HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 동기화가 필요하다.
  - **TraceId 의 동기화를 위해서 관련 메서드의 모든 파라미터를 수정해야 한다.**
  - 만약 인터페이스가 있다면 인터페이스까지 모두 고쳐야 하는 상황이다.
  - 로그를 처음 시작할 때는 begin() 을 호출하고, 처음이 아닐때는 beginSync() 를 호출해야 한다.
  - 만약에 컨트롤러를 통해서 서비스를 호출하는 것이 아니라, 다른 곳에서 서비스를 처음으로 호출하는 상황이라면 파리미터로 넘길 TraceId 가 없다.

- **HTTP 요청을 구분하고 깊이를 표현하기 위해서 TraceId 를 파라미터로 넘기는 것 말고 다른 대안은 없을까?**

- 이 예제를 작성하며 느낀건데, 트랜잭션 id를 분리한다는 개념이 클라이언트에서 없는 것 같다.

## 3. 쓰레드 로컬 - ThreadLocal

### 12. 필드 동기화 - 개발

- 앞서 로그 추적기를 만들면서 다음 로그를 출력할 때 트랜잭션ID 와 level 을 동기화 하는 문제가 있었다.
  - 이 문제를 해결하기 위해 TraceId 를 파라미터로 넘기도록 구현했다.
- 이렇게 해서 동기화는 성공했지만, 로그를 출력하는 모든 메서드에 TraceId 파라미터를 추가해야 하는 문제가 발생했다.
- TraceId 를 동기화 하는 부분만 파라미터를 사용하는 것에서 TraceId traceIdHolder 필드를 사용하도록 변경되었다.

### 13. 필드 동기화 - 적용

### 14. 필드 동기화 - 동시성 문제

- 싱글톤 객체이고 여러 요청들이 공유하기에 동시성 문제가 생긴다.
- FieldLogTrace 는 싱글톤으로 등록된 스프링 빈이다.
- 하나만 있는 인스턴스의 FieldLogTrace.traceIdHolder 필드를 여러 쓰레드가 동시에 접근하기 때문에 문제가 발생한다.

### 15. 동시성 문제 - 예제 코드

- 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라 한다.
- 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하기 때문에 트래픽이 적은 상황에서는 확률상 잘 나타나지 않고, 트래픽이 점점 많아질 수 록 자주 발생한다.
- 특히 스프링 빈 처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 한다.

- 이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다.
- 동시성 문제가 발생하는 곳은 같은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 또는 static 같은 공용 필드에 접근할 때 발생한다.
- 동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.

### 16. ThreadLocal - 소개

- 쓰레드 로컬을 사용하면 각 쓰레드마다 별도의 내부 저장소를 제공한다.
- 따라서 같은 인스턴스의 쓰레드 로컬 필드에 접근해도 문제 없다.
- 자바는 언어차원에서 쓰레드 로컬을 지원하기 위한 java.lang.ThreadLocal 클래스를 제공한다.

### 17. ThreadLocal - 예제 코드

- 해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 ThreadLocal.remove() 를 호출해서 쓰레드 로컬에 저장 된 값을 제거해주어야 한다. 제거하는 구체적인 예제는 조금 뒤에 설명하겠다.

### 18. 쓰레드 로컬 동기화 - 개발

### 19. 쓰레드 로컬 동기화 - 적용

### 20. 쓰레드 로컬 - 주의사항

- 쓰레드 로컬의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰캣)처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

- 사용자A 저장 요청
  1. 사용자A가 저장 HTTP를 요청했다.
  2. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
  3. 쓰레드 thread-A 가 할당되었다.
  4. thread-A 는 사용자A 의 데이터를 쓰레드 로컬에 저장한다.
  5. 쓰레드 로컬의 thread-A 전용 보관소에 사용자A 데이터를 보관한다.
- 사용자A 저장 요청 종료
  1. 사용자A의 HTTP 응답이 끝난다.
  2. WAS는 사용이 끝난 thread-A 를 쓰레드 풀에 반환한다. 쓰레드를 생성하는 비용은 비싸기 때문에 쓰레드를 제거하지 않고, 보통 쓰레드 풀을 통해서 쓰레드를 재사용한다.
  3. thread-A 는 쓰레드풀에 아직 살아있다. 따라서 쓰레드 로컬의 thread-A 전용 보관소에 사용자A 데이터도 함께 살아있게 된다.
- 사용자B 조회 요청

  1. 사용자B가 조회를 위한 새로운 HTTP 요청을 한다.
  2. WAS는 쓰레드 풀에서 쓰레드를 하나 조회한다.
  3. 쓰레드 thread-A 가 할당되었다. (물론 다른 쓰레드가 할당될 수 도 있다.)
  4. 이번에는 조회하는 요청이다. thread-A 는 쓰레드 로컬에서 데이터를 조회한다.
  5. 쓰레드 로컬은 thread-A 전용 보관소에 있는 사용자A 값을 반환한다.
  6. 결과적으로 사용자A 값이 반환된다.
  7. 사용자B는 사용자A의 정보를 조회하게 된다.

- **결과적으로 사용자B는 사용자A의 데이터를 확인하게 되는 심각한 문제가 발생하게 된다.**
- 쓰레드 로컬을 사용할 때는 이 부분을 꼭! 기억하자.

### 21. 정리

이것도 쓰레드로컬 API 사용법과 주의사항만 실습하면 5분 10분 컷인데...!

## 4. 템플릿 메서드 패턴과 콜백 패턴

### 22. 템플릿 메서드 패턴 - 시작

- V0는 해당 메서드가 실제 처리해야 하는 핵심 기능만 깔끔하게 남아있다.
- 반면에 V3에는 핵심 기능보다 로그를 출력해야 하는 부가 기능 코드가 훨씬 더 많고 복잡하다.

#### 핵심 기능 vs 부가 기능

- 핵심 기능은 해당 객체가 제공하는 고유의 기능이다.
  - 예를 들어서 orderService 의 핵심 기능은 주문 로직이다. 메서드 단위로 보면 orderService.orderItem() 의 핵심 기능은 주문 데이터를 저장하기 위해 리포지토리를 호출하는 orderRepository.save(itemId) 코드가 핵심 기능이다.
- 부가 기능은 핵심 기능을 보조하기 위해 제공되는 기능이다.
  - 예를 들어서 로그 추적 로직, 트랜잭션 기능이 있다.
  - 이러한 부가 기능은 단독으로 사용되지는 않고, 핵심 기능과 함께 사용된다. 예를 들어서 로그 추적 기능은 어떤핵심 기능이 호출되었는지 로그를 남기기 위해 사용한다.
  - 그러니까 핵심 기능을 보조하기 위해 존재한다.
- V0는 핵심 기능만 있지만, 로그 추적기를 추가한 V3코드는 핵심 기능과 부가 기능이 함께 섞여있다.
- V3를 보면 로그 추적기의 도입으로 핵심 기능 코드보다 부가 기능을 처리하기 위한 코드가 더 많아졌다. 소위 배보다 배꼽이 큰 상황이다. 만약 클래스가 수백 개라면 어떻게 하겠는가?

#### 변하는 것과 변하지 않는 것을 분리

- 좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.
- **여기서 핵심 기능 부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다.이 둘을 분리해서 모듈화해야 한다.**
- 템플릿 메서드 패턴(Template Method Pattern)은 이런 문제를 해결하는 디자인 패턴이다.

### 23. 템플릿 메서드 패턴 - 예제1

### 24. 템플릿 메서드 패턴 - 예제2

- 템플릿 메서드 패턴은 이름 그대로 템플릿을 사용하는 방식이다.
- 템플릿이라는 틀에 변하지 않는 부분을 몰아둔다.
- 그리고 일부 변하는 부분을 별도로 호출해서 해결한다.

- 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 둔다.
- 그리고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다.

- template1.execute() 를 호출하면 템플릿 로직인 AbstractTemplate.execute() 를 실행한다.
- 여기서 중간에 call() 메서드를 호출하는데, 이 부분이 오버라이딩 되어있다.
- 따라서 현재 인스턴스인 SubClassLogic1 인스턴스의 SubClassLogic1.call() 메서드가 호출된다.

### 25. 템플릿 메서드 패턴 - 예제3

- 템플릿 메서드 패턴은 SubClassLogic1 , SubClassLogic2 처럼 클래스를 계속 만들어야 하는 단점이 있다.
- 익명 내부 클래스를 사용하면 이런 단점을 보완할 수 있다.
- 익명 내부 클래스를 사용하면 객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속 받은 자식 클래스를 정의할 수 있다.

```java
AbstractTemplate template1 = new AbstractTemplate() {
  @Override
  protected void call() {
    log.info("비즈니스 로직1 실행");
  }
};
```

#### 해당 패턴의 의문

- JAVA에 익숙하지 않아서 그런진 모르겠지만 내 생각에는 이걸 상속으로 처리하는건 별로인 것 같다.
- 이러면 모든 클래스가 상속을 받아야할텐데, 위처럼 실행할 거라면 커먼 클래스의 스태틱으로 빼는게 더 나을 것 같다.

- 지금 하신 고민이 바로 **"템플릿 메서드 패턴(상속 기반)"**과 **"전략 패턴(인터페이스 주입 또는 위임 기반)"**의 차이를 고민하기 시작한 것입니다.

1. "상속으로 처리하는 건 별로인 것 같다." - 정확합니다!

템플릿 메서드 패턴은 **상속**을 사용하기 때문에 몇 가지 명확한 단점을 가집니다.

- **강한 결합(Tight Coupling)**: 자식 클래스는 부모 클래스와 아주 강력하게 묶입니다. 부모 클래스의 변경이 모든 자식 클래스에 영향을 미칠 수 있습니다.
- **유연성 부족**: 자바는 다중 상속을 지원하지 않습니다. 만약 어떤 클래스가 이미 다른 중요한 클래스를 상속받고 있다면, 템플릿 메서드를 사용하기 위해 또 다른 클래스를 상속할 수 없습니다.
- **런타임에 변경 불가**: 어떤 로직을 사용할지가 컴파일 시점에 상속 구조로 고정됩니다. 실행 중에 동적으로 로직을 바꾸기가 어렵습니다.

이러한 단점 때문에 "상속보다는 구성을 사용하라(Favor Composition over Inheritance)"는 객체 지향 설계의 유명한 원칙이 나온 것입니다.

"커먼 클래스의 스태틱으로 빼는 게 더 나을 것 같다." - 훌륭한 대안입니다!

이 아이디어가 바로 **전략 패턴(Strategy Pattern)**의 가장 기본적인 형태와 맞닿아 있습니다. 로직의 '뼈대'를 제공하고, '내용물'을 외부에서 주입받는 방식이죠.

그럼 템플릿 메서드는 언제 쓸까요?

템플릿 메서드 패턴이 여전히 유용한 경우가 있습니다. 바로 **"로직의 흐름을 명확하게 강제하고 싶을 때"** 입니다.

- **프레임워크 개발**: 개발자가 따라야 할 명확한 '뼈대'나 '생명주기(Lifecycle)'를 제공해야 할 때 매우 유용합니다. 예를 들어 게임을 만들 때 `onLoad()` -> `onUpdate()` -> `onRender()` -> `onRelease()` 순서가 반드시 지켜져야 하는 경우, 개발자는 각 단계의 내용만 채우도록 강제할 수 있습니다.
- **실수 방지**: 특정 로직의 실행 순서나 필수적인 전후 처리(예: 리소스 할당 및 해제)가 매우 중요해서, 자식 클래스가 이를 어기면 안 되는 경우에 사용합니다. 부모 클래스가 흐름을 완전히 통제하므로 더 안전합니다.

| 관점              | 템플릿 메서드 패턴 (상속)                        | 전략 패턴 / 유틸리티 클래스 (위임)               |
| :---------------- | :----------------------------------------------- | :----------------------------------------------- |
| **핵심 아이디어** | "흐름은 내가 정할 테니, 넌 빈칸만 채워."         | "필요한 부품을 가져오면, 내가 조립해 줄게."      |
| **강제성**        | 높음 (정해진 구조를 반드시 따라야 함)            | 낮음 (필요할 때 골라서 사용)                     |
| **유연성**        | 낮음 (상속으로 구조가 고정됨)                    | 높음 (다양한 클래스에서 재사용 가능)             |
| **적합한 상황**   | 프레임워크, 라이브러리 등 **'뼈대'**를 제공할 때 | 일반적인 비즈니스 로직 등 **'기능'**을 제공할 때 |

### 26. 템플릿 메서드 패턴 - 적용1

- 제네릭에서 반환 타입이 필요한데, 반환할 내용이 없으면 Void 타입을 사용하고 null 을 반환하면 된다.
- 참고로 제네릭은 기본 타입인 void , int 등을 선언할 수 없다.

### 27. 템플릿 메서드 패턴 - 적용2

- 진정한 좋은 설계는 바로 변경이 일어날 때 자연스럽게 드러난다.
- 지금까지 로그를 남기는 부분을 모아서 하나로 모듈화하고, 비즈니스 로직 부분을 분리했다.
- 여기서 만약 로그를 남기는 로직을 변경해야 한다고 생각해보자. 그래서 AbstractTemplate 코드를 변경해야 한다 가정해보자. 단순히 AbstractTemplate 코드만 변경하면 된다.
- 템플릿이 없는 V3 상태에서 로그를 남기는 로직을 변경해야 한다고 생각해보자. 이 경우 모든 클래스를 다 찾아서 고쳐야 한다. 클래스가 수백 개라면 생각만해도 끔찍하다.

- 단일 책임 원칙(SRP)
- V4 는 단순히 템플릿 메서드 패턴을 적용해서 소스코드 몇줄을 줄인 것이 전부가 아니다.
- 로그를 남기는 부분에 단일 책임 원칙(SRP)을 지킨 것이다. 변경 지점을 하나로 모아서 변경에 쉽게 대처할 수 있는 구조를 만든 것이다.

### 28. 템플릿 메서드 패턴 - 정의

- GOF 템플릿 메서드 패턴 정의: 작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다.

- 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 일부 변경되는 로직은 자식 클래스에 정의하는 것이다. 이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다.
- 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.

#### 단점

- 템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점들을 그대로 안고간다. 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다.
  - 이것은 의존관계에 대한 문제이다. 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.
  - 이번 장에서 지금까지 작성했던 코드를 떠올려보자. 자식 클래스를 작성할 때 부모 클래스의 기능을 사용한 것이 있었던가?
  - 그럼에도 불구하고 템플릿 메서드 패턴을 위해 자식 클래스는 부모 클래스를 상속 받고 있다.
- 상속을 받는다는 것은 특정 부모 클래스를 의존하고 있다는 것이다.
- UML에서 상속을 받으면 삼각형 화살표가 자식 -> 부모 를 향하고 있는 것은 이런 의존관계를 반영하는 것이다.

- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는데, 부모 클래스를 알아야한다. 이것은 좋은 설계가 아니다.
- 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.
- 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 전략 패턴(Strategy Pattern)이다.

### 29. 전략 패턴 - 시작

### 30. 전략 패턴 - 예제1

### 31. 전략 패턴 - 예제2

### 32. 전략 패턴 - 예제3

### 33. 템플릿 콜백 패턴 - 시작

### 34. 템플릿 콜백 패턴 - 예제

### 35. 템플릿 콜백 패턴 - 적용

### 36. 정리

## 5. 프록시 패턴과 데코레이터 패턴

### 37. 프로젝트 생성

### 38. 예제 프로젝트 만들기 v1

### 39. 예제 프로젝트 만들기 v2

### 40. 예제 프로젝트 만들기 v3

### 41. 요구사항 추가

### 42. 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

### 43. 프록시 패턴 - 예제 코드1

### 44. 프록시 패턴 - 예제 코드2

### 45. 데코레이터 패턴 - 예제 코드1

### 46. 데코레이터 패턴 - 예제 코드2

### 47. 데코레이터 패턴 - 예제 코드3

### 48. 프록시 패턴과 데코레이터 패턴 정리

### 49. 인터페이스 기반 프록시 - 적용

### 50. 구체 클래스 기반 프록시 - 예제1

### 51. 구체 클래스 기반 프록시 - 예제2

### 52. 구체 클래스 기반 프록시 - 적용

### 53. 인터페이스 기반 프록시와 클래스 기반 프록시

### 54. 정리

## 6. 동적 프록시 기술

### 55. 리플렉션

### 56. JDK 동적 프록시 - 소개

### 57. JDK 동적 프록시 - 예제 코드

### 58. JDK 동적 프록시 - 적용1

### 59. JDK 동적 프록시 - 적용2

### 60. CGLIB - 소개

### 61. CGLIB - 예제 코드

### 62. 정리

## 7. 스프링이 지원하는 프록시

### 63. 프록시 팩토리 - 소개

### 64. 프록시 팩토리 - 예제 코드1

### 65. 프록시 팩토리 - 예제 코드2

### 66. 포인트컷, 어드바이스, 어드바이저 - 소개

### 67. 예제 코드1 - 어드바이저

### 68. 예제 코드2 - 직접 만든 포인트컷

### 69. 예제 코드3 - 스프링이 제공하는 포인트컷

### 70. 예제 코드4 - 여러 어드바이저 함께 적용

### 71. 프록시 팩토리 - 적용1

### 72. 프록시 팩토리 - 적용2

### 73. 정리

## 8. 빈 후처리기

### 74. 빈 후처리기 - 소개

### 75. 빈 후처리기 - 예제 코드1

### 76. 빈 후처리기 - 예제 코드2

### 77. 빈 후처리기 - 적용

### 78. 빈 후처리기 - 정리

### 79. 스프링이 제공하는 빈 후처리기1

### 80. 스프링이 제공하는 빈 후처리기2

### 81. 하나의 프록시, 여러 Advisor 적용

### 82. 정리

## 9. @Aspect AOP

### 83. @Aspect 프록시 - 적용

### 84. @Aspect 프록시 - 설명

### 85. 정리

## 10. 스프링 AOP 개념

### 86. AOP 소개 - 핵심 기능과 부가 기능

### 87. AOP 소개 - 애스펙트

### 88. AOP 적용 방식

### 89. AOP 용어 정리

### 90. 정리

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

### 95. 스프링 AOP 구현3 - 어드바이스 추가

### 96. 스프링 AOP 구현4 - 포인트컷 참조

### 97. 스프링 AOP 구현5 - 어드바이스 순서

### 98. 스프링 AOP 구현6 - 어드바이스 종류

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리

## 15. 다음으로

### 125. 다음으로
