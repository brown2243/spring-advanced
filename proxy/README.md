# [스프링 핵심 원리 - 고급편](../)

## 5. 프록시 패턴과 데코레이터 패턴

### 37. 프로젝트 생성

### 38. 예제 프로젝트 만들기 v1

- v1 - 인터페이스와 구현 클래스 - 스프링 빈으로 수동 등록
- v2 - 인터페이스 없는 구체 클래스 - 스프링 빈으로 수동 등록
- v3 - 컴포넌트 스캔으로 스프링 빈 자동 등록

- @Import(AppV1Config.class) : 클래스를 스프링 빈으로 등록한다.
- @SpringBootApplication(scanBasePackages = "hello.proxy.app"): 컴포넌트 스캔을 시작할 위치를 지정한다. 해당 패키지와 그 하위 패키지를 컴포넌트 스캔한다.

### 39. 예제 프로젝트 만들기 v2

### 40. 예제 프로젝트 만들기 v3

- **개발할 때, V3가 일반적이다.**
- V1 방식을 사용해야 할 때
  - 구현체를 쉽게 갈아 끼워야 할 때 (DI의 핵심)
    - 인터페이스에만 의존하므로, 서비스 코드 수정 없이 설정 파일에서 @Bean으로 등록하는 구현체만 변경
  - Spring AOP의 프록시를 적용할 때
    - 스프링의 AOP는 기본적으로 프록시 기술을 사용합니다.
    - 인터페이스가 있으면 스프링은 JDK 동적 프록시를 사용하여 프록시를 더 쉽게 만들어냅니다.
- V2: 구체 클래스 수동 등록
  - 직접 수정할 수 없는 외부 라이브러리의 클래스를 빈으로 등록할 때 사용

### 41. 요구사항 추가

- 가장 어려운 문제는 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입하는 것이다. 이 문제를 해결하려면 프록시(Proxy)의 개념을 먼저 이해해야 한다.

### 42. 프록시, 프록시 패턴, 데코레이터 패턴 - 소개

- 클라이언트와 서버의 기본 개념을 정의하면 클라이언트는 서버에 필요한 것을 요청하고, 서버는 클라이언트의 요청을 처리하는 것이다.

- 그런데 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아니라 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할 수 있다.
- 예를 들어서 내가 직접 마트에서 장을 볼 수도 있지만, 누군가에게 대신 장을 봐달라고 부탁할 수도 있다.
- **여기서 대신 장을 보는 대리자를 영어로 프록시(Proxy)라 한다.**
- 재미있는 점은 직접 호출과 다르게 간접 호출을 하면 대리자가 중간에서 여러가지 일을 할 수 있다는 점이다.
- 엄마에게 라면을 사달라고 부탁 했는데, 엄마는 그 라면은 이미 집에 있다고 할 수도 있다. 그러면 기대한 것 보다 더 빨리 라면을 먹을 수 있다. (접근 제어, 캐싱)
- 아버지께 자동차 주유를 부탁했는데, 아버지가 주유 뿐만 아니라 세차까지 하고 왔다. 클라이언트가 기대한 것 외에 세차라는 부가 기능까지 얻게 되었다. (부가 기능 추가)
- 그리고 대리자가 또 다른 대리자를 부를 수도 있다. 예를 들어서 내가 동생에게 라면을 사달라고 했는데, 동생은 또 다른 누군가에게 라면을 사달라고 다시 요청할 수도 있다.
- 중요한 점은 클라이언트는 대리자를 통해서 요청했기 때문에 그 이후 과정은 모른다는 점이다. 동생을 통해서 라면이 나에게 도착하기만 하면 된다. (프록시 체인)

#### 대체 가능

- 객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.
- 그러므로 서버와 프록시는 같은 인터페이스를 사용해야 한다.
- 클라이언트 객체에 DI를 사용해서 Client -> Server 에서 Client -> Proxy 로 객체 의존관계를 변경해도 클라이언트 코드를 전혀 변경하지 않아도 된다. 클라이언트 입장에서는 변경 사실 조차 모른다.
- DI를 사용하면 클라이언트 코드의 변경 없이 유연하게 프록시를 주입할 수 있다.

#### 프록시의 주요 기능

- 프록시 객체가 중간에 있으면 크게 접근 제어와 부가 기능 추가를 수행할 수 있다.
- 접근 제어
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 추가
  - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
  - 예) 요청 값이나, 응답 값을 중간에 변형한다.
  - 예) 실행 시간을 측정해서 추가 로그를 남긴다.

#### GOF 디자인 패턴

- 둘다 프록시를 사용하는 방법이지만 GOF 디자인 패턴에서는 이 둘을 의도(intent)에 따라서 프록시 패턴과 데코레이터 패턴으로 구분한다.
- 프록시 패턴: 접근 제어가 목적
- 데코레이터 패턴: 새로운 기능 추가가 목적
- 둘다 프록시를 사용하지만, 의도가 다르다는 점이 핵심이다.

### 43. 프록시 패턴 - 예제 코드1

- 이 데이터가 한번 조회하면 변하지 않는 데이터라면 어딘가에 보관해두고 이미 조회한 데이터를 사용하는 것이 성능상 좋다.
- 이런 것을 캐시라고 한다.
- 프록시 패턴의 주요 기능은 접근 제어이다. 캐시도 접근 자체를 제어하는 기능 중 하나이다.

### 44. 프록시 패턴 - 예제 코드2

- client -> cacheProxy -> realSubject 런타임 객체 의존 관계가 완성된다.
- 프록시 패턴의 핵심은 RealSubject 코드와 클라이언트 코드를 전혀 변경하지 않고, 프록시를 도입해서 접근 제어를 했다는 점이다.

### 45. 데코레이터 패턴 - 예제 코드1

### 46. 데코레이터 패턴 - 예제 코드2

- 프록시로 부가 기능을 추가하는 것을 데코레이터 패턴이라 한다.

### 47. 데코레이터 패턴 - 예제 코드3

### 48. 프록시 패턴과 데코레이터 패턴 정리

- 디자인 패턴에서 중요한 것은 해당 패턴의 겉모양이 아니라 의도에 따라 패턴을 구분한다.

- 프록시 패턴의 의도: 다른 개체에 대한 접근을 제어하기 위해 대리자를 제공
- 데코레이터 패턴의 의도: 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공

- 프록시를 사용하고 해당 프록시가 접근 제어가 목적이라면 프록시 패턴이고, 새로운 기능을 추가하는 것이 목적이라면 데코레이터 패턴이 된다.

### 49. 인터페이스 기반 프록시 - 적용

- 프록시를 사용하면 기존 코드를 전혀 수정하지 않고 로그 추적 기능을 도입할 수 있다.

1. Controller , Service , Repository 각각 인터페이스에 맞는 프록시 구현체를 추가한다.
2. 런타임에 프록시를 사용하도록 의존 관계 설정

### 50. 구체 클래스 기반 프록시 - 예제1

### 51. 구체 클래스 기반 프록시 - 예제2

- 지금까지 인터페이스를 기반으로 프록시를 도입했다.
- 그런데 자바의 다형성은 인터페이스를 구현하든, 아니면 클래스를 상속하든 상위 타입만 맞으면 다형성이 적용된다.
- 이번에는 인터페이스가 아니라 클래스를 기반으로 상속을 받아서 프록시를 만들어보겠다.

### 52. 구체 클래스 기반 프록시 - 적용

- 클래스 기반의 프록시는 구체 클래스를 상속받아 구현
- 프록시는 부모 객체의 기능을 사용하지 않기 때문에 super(null) 을 입력해도 된다.

### 53. 인터페이스 기반 프록시와 클래스 기반 프록시

- 인터페이스가 없어도 클래스 기반으로 프록시를 생성할 수 있다.
- 클래스 기반 프록시는 해당 클래스에만 적용할 수 있다.
- 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용할 수 있다.
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.

  - 부모 클래스의 생성자를 호출해야 한다.(앞서 본 예제)
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다.
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

- 인터페이스 기반의 프록시는 상속이라는 제약에서 자유롭다.
- 프로그래밍 관점에서도 인터페이스를 사용하는 것이 역할과 구현을 명확하게 나누기 때문에 더 좋다.
- 인터페이스 기반 프록시의 단점은 인터페이스가 필요하다는 그 자체이다.
- 이론적으로는 모든 객체에 인터페이스를 도입해서 역할과 구현을 나누는 것이 좋다.
- 하지만 실제로는 구현을 거의 변경할 일이 없는 클래스도 많다.
- **인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적인데, 구현을 변경할 가능성이 거의 없는 코드에 무작정 인터페이스를 사용하는 것은 번거롭고 그렇게 실용적이지 않다.**
- 이런곳에는 실용적인 관점에서 인터페이스를 사용하지 않고 구체 클래스를 바로 사용하는 것이 좋다 생각한다.

#### 너무 많은 프록시 클래스

- 지금까지 프록시를 사용해서 기존 코드를 변경하지 않고, 로그 추적기라는 부가 기능을 적용할 수 있었다.
- 그런데 문제는 프록시 클래스를 너무 많이 만들어야 한다는 점이다.
  - 잘 보면 프록시 클래스가 하는 일은 LogTrace 를 사용하는 것인데, 그 로직이 모두 똑같다. 대상 클래스만 다를 뿐이다.
  - 만약 적용해야 하는 대상 클래스가 100개라면 프록시 클래스도 100개를 만들어야한다.
- 바로 다음에 설명할 동적 프록시 기술이 이 문제를 해결해준다.

### 54. 정리

## 6. 동적 프록시 기술

### 55. 리플렉션

- [JS에도 Reflect API가 있다](https://inpa.tistory.com/entry/JS-%F0%9F%93%9A-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Proxy-Reflect-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%B2%95).

- 자바가 기본으로 제공하는 JDK 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다.
- 프록시를 적용할 코드를 하나만 만들어두고 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면 된다.
- JDK 동적 프록시를 이해하기 위해서는 먼저 자바의 리플렉션 기술을 이해해야 한다.
- 리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.

- 쉬워 보이지만 메서드로 뽑아서 공통화하는 것이 생각보다 어렵다. 왜냐하면 중간에 호출하는 메서드가 다르기 때문이다.

  - 이 부분은 사실 자바는 함수를 인자로 넘길 수 없어서 그렇다.
  - 8부터는 람다(Lambda) 덕분에 마치 함수를 직접 넘기는 것처럼 이 방식을 아주 간결하게 표현할 수 있다

- **리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.**
- **리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.**
- 따라서 리플렉션은 일반적으로 사용하면 안된다.
- 리플렉션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다.

### 56. JDK 동적 프록시 - 소개

- 동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다.
- **프록시 객체를 동적으로 런타임에 개발자 대신 만들어준다. 그리고 동적 프록시에 원하는 실행 로직을 지정할 수 있다.**
- JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. **따라서 인터페이스가 필수이다.**

### 57. JDK 동적 프록시 - 예제 코드

1. 클라이언트는 JDK 동적 프록시의 call() 을 실행한다.
2. JDK 동적 프록시는 InvocationHandler.invoke() 를 호출한다. TimeInvocationHandler 가 구현체로 있으로 TimeInvocationHandler.invoke() 가 호출된다.
3. TimeInvocationHandler 가 내부 로직을 수행하고, method.invoke(target, args) 를 호출해서 target 인 실제 객체( AImpl )를 호출한다.
4. AImpl 인스턴스의 call() 이 실행된다.
5. AImpl 인스턴스의 call() 의 실행이 끝나면 TimeInvocationHandler 로 응답이 돌아온다. 시간 로그를 출력하고 결과를 반환한다.

- JDK 동적 프록시 기술 덕분에 적용 대상 만큼 프록시 객체를 만들지 않아도 된다.
- 같은 부가 기능 로직을 한번만 개발해서 공통으로 적용할 수 있다.
- 적용 대상이 100개여도 동적 프록시를 통해서 생성하고, 각각 필요한 InvocationHandler 만 만들어서 넣어주면 된다.
- **결과적으로 프록시 클래스를 수 없이 만들어야 하는 문제도 해결하고, 부가 기능 로직도 하나의 클래스에 모아서 단일 책임 원칙(SRP)도 지킬 수 있게 되었다.**

### 58. JDK 동적 프록시 - 적용1

1. 클라이언트의 호출: 클라이언트가 proxy.call()처럼 프록시 객체의 메서드를 호출합니다.
2. JVM의 가로채기: JVM은 이 객체가 동적 프록시인 것을 인지하고, call() 메서드를 직접 실행하는 대신 이 프록시와 연결된 InvocationHandler(즉, LogTraceBasicHandler)를 찾아냅니다.
3. 핸들러에게 위임: JVM은 방금 호출된 call 메서드의 정보(Method 객체), 인자(args 배열) 등을 모두 담아서 LogTraceBasicHandler의 invoke 메서드를 실행시킵니다.
4. 핸들러 로직 실행: invoke 메서드 내부의 코드가 실행됩니다.
5. method.invoke(target, args): 리플렉션을 사용해 드디어 **원본 객체(target)**의 실제 메서드를 호출합니다. (핵심 기능 위임)
6. 결과 반환: invoke 메서드가 반환한 결과가 최종적으로 클라이언트에게 전달됩니다.

#### JS/TS Proxy 객체와의 비교

- 자바의 JDK 동적 프록시는 인터페이스를 기반으로 동작하기 때문에, 인터페이스에 정의된 메서드 호출만 가로챌 수 있습니다.
- 인터페이스에는 멤버 변수(프로퍼티/필드)를 정의할 수 없으므로, target 객체의 프로퍼티에 직접 접근하는 것을 중간에서 가로채는 개념 자체가 없습니다.
- JS/TS의 Proxy는 메서드 호출뿐만 아니라 프로퍼티(속성)에 대한 접근도 가로챌 수 있습니다. 이는 handler 객체에 정의하는 트랩(Trap) 덕분입니다.

- 결론적으로 자바의 프록시 기술(JDK 동적 프록시, CGLIB)은 근본적으로 메서드 호출을 가로채는 데에 초점이 맞춰져 있습니다.

### 59. JDK 동적 프록시 - 적용2

### 60. CGLIB - 소개

- CGLIB는 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.
- CGLIB를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
- CGLIB는 원래는 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함했다.
- 따라서 스프링을 사용한다면 별도의 외부 라이브러리를 추가하지 않아도 사용할 수 있다.

- 참고로 우리가 CGLIB를 직접 사용하는 경우는 거의 없다.
- 이후에 설명할 스프링의 ProxyFactory 라는 것이 이 기술을 편리하게 사용하게 도와주기 때문에, 너무 깊이있게 파기 보다는 CGLIB가 무엇인지 대략 개념만 잡으면 된다.

### 61. CGLIB - 예제 코드

- JDK 동적 프록시는 인터페이스를 구현(implement)해서 프록시를 만든다.
- CGLIB는 구체 클래스를 상속(extends)해서 프록시를 만든다.

#### CGLIB 제약

- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 있다.
- 부모 클래스의 생성자를 체크해야 한다. CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요하다.
- 클래스에 final 키워드가 붙으면 상속이 불가능하다. CGLIB에서는 예외가 발생한다.
- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.
- CGLIB에서는 프록시 로직이 동작하지 않는다.

### 62. 정리

- 남은 문제
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해서 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor 를 각각 중복으로 만들어서 관리해야 할까?
- 특정 조건에 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?

## 7. 스프링이 지원하는 프록시

### 63. 프록시 팩토리 - 소개

### 64. 프록시 팩토리 - 예제 코드1

### 65. 프록시 팩토리 - 예제 코드2

### 66. 포인트컷, 어드바이스, 어드바이저 - 소개

### 67. 예제 코드1 - 어드바이저

### 68. 예제 코드2 - 직접 만든 포인트컷

### 69. 예제 코드3 - 스프링이 제공하는 포인트컷

### 70. 예제 코드4 - 여러 어드바이저 함께 적용

### 71. 프록시 팩토리 - 적용1

### 72. 프록시 팩토리 - 적용2

### 73. 정리

## 8. 빈 후처리기

### 74. 빈 후처리기 - 소개

### 75. 빈 후처리기 - 예제 코드1

### 76. 빈 후처리기 - 예제 코드2

### 77. 빈 후처리기 - 적용

### 78. 빈 후처리기 - 정리

### 79. 스프링이 제공하는 빈 후처리기1

### 80. 스프링이 제공하는 빈 후처리기2

### 81. 하나의 프록시, 여러 Advisor 적용

### 82. 정리

## 9. @Aspect AOP

### 83. @Aspect 프록시 - 적용

### 84. @Aspect 프록시 - 설명

### 85. 정리

## 10. 스프링 AOP 개념

### 86. AOP 소개 - 핵심 기능과 부가 기능

### 87. AOP 소개 - 애스펙트

### 88. AOP 적용 방식

### 89. AOP 용어 정리

### 90. 정리

## 11. 스프링 AOP 구현

### 91. 프로젝트 생성

### 92. 예제 프로젝트 만들기

### 93. 스프링 AOP 구현1 - 시작

### 94. 스프링 AOP 구현2 - 포인트컷 분리

### 95. 스프링 AOP 구현3 - 어드바이스 추가

### 96. 스프링 AOP 구현4 - 포인트컷 참조

### 97. 스프링 AOP 구현5 - 어드바이스 순서

### 98. 스프링 AOP 구현6 - 어드바이스 종류

### 99. 정리

## 12. 스프링 AOP - 포인트컷

### 100. 포인트컷 지시자

### 101. 예제 만들기

### 102. execution - 1

### 103. execution - 2

### 104. within

### 105. args

### 106. @target, @within

### 107. @annotation, @args

### 108. bean

### 109. 매개변수 전달

### 110. this, target

### 111. 정리

## 13. 스프링 AOP - 실전 예제

### 112. 예제 만들기

### 113. 로그 출력 AOP

### 114. 재시도 AOP

### 115. 정리

## 14. 스프링 AOP - 실무 주의사항

### 116. 프록시와 내부 호출 - 문제

### 117. 프록시와 내부 호출 - 대안1 자기 자신 주입

### 118. 프록시와 내부 호출 - 대안2 지연 조회

### 119. 프록시와 내부 호출 - 대안3 구조 변경

### 120. 프록시 기술과 한계 - 타입 캐스팅

### 121. 프록시 기술과 한계 - 의존관계 주입

### 122. 프록시 기술과 한계 - CGLIB

### 123. 프록시 기술과 한계 - 스프링의 해결책

### 124. 정리

## 15. 다음으로

### 125. 다음으로
